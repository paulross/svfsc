<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sparse Virtual File System: /Users/paulross/CLionProjects/cppSVF/src/cp/_cSVF.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sparse Virtual File System
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">A Sparse Virtual File System.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_0b7eedc511094c69737ebf3243114686.html">cp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">_cSVF.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="cp__svfs_8h_source.html">cp_svfs.h</a>&quot;</code><br />
<code>#include &lt;ctime&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &quot;<a class="el" href="svf_8h_source.html">svf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="svfs__util_8h_source.html">svfs_util.h</a>&quot;</code><br />
</div>
<p><a href="__c_s_v_f_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python wrapper around a C++ SparseVirtualFile.  <a href="structcp___sparse_virtual_file.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acquire_lock_s_v_f.html">AcquireLockSVF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RAII wrapper around the PyThread_type_lock for the CPython SVF.  <a href="class_acquire_lock_s_v_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af631b17b1e5840bc33df4bbe08dbcbbb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#af631b17b1e5840bc33df4bbe08dbcbbb">SVFS_SVF_METHOD_SIZE_T_WRAPPER</a>(method_name,  docstring)</td></tr>
<tr class="separator:af631b17b1e5840bc33df4bbe08dbcbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bb1019d146031999de58fff545accc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#aa4bb1019d146031999de58fff545accc">ASSERT_FUNCTION_ENTRY_SVF</a>(member)</td></tr>
<tr class="separator:aa4bb1019d146031999de58fff545accc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5781c10b8d991ef69592569ae4267d15"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a5781c10b8d991ef69592569ae4267d15">cp_SparseVirtualFile_new</a> (PyTypeObject *type, PyObject *Py_UNUSED(args), PyObject *Py_UNUSED(kwds))</td></tr>
<tr class="separator:a5781c10b8d991ef69592569ae4267d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1106f66d8bdca88bfdf3b42bfaaa0c2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#ab1106f66d8bdca88bfdf3b42bfaaa0c2">cp_SparseVirtualFile_init</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self, PyObject *args, PyObject *kwargs)</td></tr>
<tr class="separator:ab1106f66d8bdca88bfdf3b42bfaaa0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147fa3eb67dd4958d0da4813beba9b17"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a147fa3eb67dd4958d0da4813beba9b17">cp_SparseVirtualFile_dealloc</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self)</td></tr>
<tr class="separator:a147fa3eb67dd4958d0da4813beba9b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76f2ef83d2a9d4704e1e980e2a4d087"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#af76f2ef83d2a9d4704e1e980e2a4d087">PyDoc_STRVAR</a> (cp_SparseVirtualFile_id_docstring, &quot;id(self) -&gt; str\n\n&quot; &quot;Returns the ID of the Sparse Virtual File.&quot;)</td></tr>
<tr class="separator:af76f2ef83d2a9d4704e1e980e2a4d087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afd8d13ca7aa1f150f391d4e772c765"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a5afd8d13ca7aa1f150f391d4e772c765">cp_SparseVirtualFile_id</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self)</td></tr>
<tr class="separator:a5afd8d13ca7aa1f150f391d4e772c765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc10e80de31d5e1174b7779da24437a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a5bc10e80de31d5e1174b7779da24437a">SVFS_SVF_METHOD_SIZE_T_WRAPPER</a> (size_of, &quot;Returns the estimate of total memory usage of the Sparse Virtual File.&quot;)</td></tr>
<tr class="separator:a5bc10e80de31d5e1174b7779da24437a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2db3591d2119af3833b31973a786c39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#aa2db3591d2119af3833b31973a786c39">SVFS_SVF_METHOD_SIZE_T_WRAPPER</a> (num_bytes, &quot;Returns the total number of file bytes held by the Sparse Virtual File.&quot;)</td></tr>
<tr class="separator:aa2db3591d2119af3833b31973a786c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad851e5570f4f97c4d61ef75da3673cac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#ad851e5570f4f97c4d61ef75da3673cac">SVFS_SVF_METHOD_SIZE_T_WRAPPER</a> (num_blocks, &quot;Returns the total number of blocks of data held by the Sparse Virtual File System.&quot;)</td></tr>
<tr class="separator:ad851e5570f4f97c4d61ef75da3673cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad043247e943996f4582b53867bce9da5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#ad043247e943996f4582b53867bce9da5">SVFS_SVF_METHOD_SIZE_T_WRAPPER</a> (last_file_position, &quot;Returns the file position immediately past the last block.&quot;)</td></tr>
<tr class="separator:ad043247e943996f4582b53867bce9da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0983ec9ed5b3d32bfa17db098f581486"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a0983ec9ed5b3d32bfa17db098f581486">PyDoc_STRVAR</a> (cp_SparseVirtualFile_has_data_docstring, &quot;has_data(self, file_position: int, length: int) -&gt; bool\n\n&quot; &quot;Checks if the Sparse Virtual File of the ID has data at the given ``file_position`` and ``length``.\n\n&quot; &quot;Parameters\n\n&quot; &quot;file_position: int\n&quot; &quot;    The absolute file position of the start of the data.\n\n&quot; &quot;length: int\n&quot; &quot;    The length of the required data in bytes.\n\n&quot; &quot;Returns\n\n&quot; &quot;bool: True if the SVF contains the data, False otherwise.&quot;)</td></tr>
<tr class="separator:a0983ec9ed5b3d32bfa17db098f581486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaecc0b011d5e60bb958e1841bbc3f03"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#aaaecc0b011d5e60bb958e1841bbc3f03">cp_SparseVirtualFile_has_data</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self, PyObject *args, PyObject *kwargs)</td></tr>
<tr class="separator:aaaecc0b011d5e60bb958e1841bbc3f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37067b0baf903304708173b2f6fb8ff2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a37067b0baf903304708173b2f6fb8ff2">PyDoc_STRVAR</a> (cp_SparseVirtualFile_write_docstring, &quot;write(self, file_position: int, data: bytes) -&gt; None\n\n&quot; &quot;Writes the data to the Sparse Virtual File of the given ID at ``file_position`` and ``data`` as a ``bytes`` object.&quot; &quot; This will raise an ``IOError`` if ``self.compare_for_diff`` is True and given data is different than&quot; &quot; that seen before and only new data up to this point will be written.&quot; &quot; If the ``byte`` data is empty nothing will be done.&quot; &quot; This will raise a RuntimeError if the data can not be written for any other reason&quot;)</td></tr>
<tr class="separator:a37067b0baf903304708173b2f6fb8ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bda1aff1ac4be7170f7ca4225ce5d72"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a2bda1aff1ac4be7170f7ca4225ce5d72">cp_SparseVirtualFile_write</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self, PyObject *args, PyObject *kwargs)</td></tr>
<tr class="separator:a2bda1aff1ac4be7170f7ca4225ce5d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56a02b2bcbed1e96aac28ccd1f8a3ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#ae56a02b2bcbed1e96aac28ccd1f8a3ac">PyDoc_STRVAR</a> (cp_SparseVirtualFile_read_docstring, &quot;read(self, file_position: int, length: int) -&gt; bytes\n\n&quot; &quot;Read the data from the Sparse Virtual File at ``file_position`` and ``length`` returning a ``bytes`` object.&quot; &quot; This takes a file position and a length.&quot; &quot; This will raise an ``IOError`` if any data is not present&quot; &quot; This will raise a ``RuntimeError`` if the data can not be read for any other reason&quot;)</td></tr>
<tr class="separator:ae56a02b2bcbed1e96aac28ccd1f8a3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c3a042105cc16cf80d25e729395aad"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a05c3a042105cc16cf80d25e729395aad">private_SparseVirtualFile_svf_read_as_py_bytes</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self, unsigned long long fpos, unsigned long long len)</td></tr>
<tr class="separator:a05c3a042105cc16cf80d25e729395aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623988da94f7f5d587bbd2bd9bc77209"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a623988da94f7f5d587bbd2bd9bc77209">cp_SparseVirtualFile_read</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self, PyObject *args, PyObject *kwargs)</td></tr>
<tr class="separator:a623988da94f7f5d587bbd2bd9bc77209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb8195fbc1ad7da04aa79dc2f4d432d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a8cb8195fbc1ad7da04aa79dc2f4d432d">PyDoc_STRVAR</a> (cp_SparseVirtualFile_erase_docstring, &quot;erase(self, file_position: int) -&gt; None\n\n&quot; &quot;Erase the data from the Sparse Virtual File at the given ``file_position``&quot; &quot; which must be the beginning of a block.\n&quot; &quot;This will raise an ``IOError`` if a block is not present at that file position.&quot;)</td></tr>
<tr class="separator:a8cb8195fbc1ad7da04aa79dc2f4d432d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425ca0f68fffc47749ec6653d2ecafcd"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a425ca0f68fffc47749ec6653d2ecafcd">cp_SparseVirtualFile_erase</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self, PyObject *args, PyObject *kwargs)</td></tr>
<tr class="separator:a425ca0f68fffc47749ec6653d2ecafcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507ad11800c262a3d89eeaccfcea7131"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a507ad11800c262a3d89eeaccfcea7131">PyDoc_STRVAR</a> (cp_SparseVirtualFile_need_docstring, &quot;need(self, file_position: int, length: int, greedy_length: int = 0) -&gt; typing.Tuple[typing.Tuple[int, int], ...]\n\n&quot; &quot;Given a file_position and length this returns a ordered list ``[(file_position, length), ...]`` of seek/read&quot; &quot; instructions of data that is required to be written to the Sparse Virtual File so that a subsequent read will&quot; &quot; succeed.\n&quot; &quot; If greedy_length is &gt; 0 then, if possible, blocks will be coalesced to reduce the size of the return value.&quot; &quot;\n\n&quot; &quot;.. warning::\n&quot; &quot;    The SVF has no knowledge of the the actual file size so when using a greedy length the need list might&quot; &quot; include positions beyond EOF.\n\n&quot; &quot;    For example a file 1024 bytes long and a greedy length of 256 then ``need(1000, 24, 256)`` will create&quot; &quot; a need list of ``[(1000, 256),]``.&quot; &quot; This should generate a ``write(1000, 24)`` not a ``write(1000, 256)``.\n\n&quot; &quot;    It is up to the caller to handle this, however, ``reads()`` in C/C++/Python will ignore read lengths past&quot; &quot; EOF so the caller does not have to do anything.\n\n&quot; &quot;\n\nUsage::\n\n&quot; &quot;    if not svf.has_data(position, length):\n&quot; &quot;        for read_fpos, read_length in svf.need(position, length):\n&quot; &quot;            # Somehow get data as a bytes object at read_fpos, read_length...\n&quot; &quot;            svf.write(read_fpos, data)\n&quot; &quot;    return svf.read(position, length):\n&quot;)</td></tr>
<tr class="separator:a507ad11800c262a3d89eeaccfcea7131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb25162f6c4b7b7f6d93381632ab74a"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#adbb25162f6c4b7b7f6d93381632ab74a">cp_SparseVirtualFile_need</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self, PyObject *args, PyObject *kwargs)</td></tr>
<tr class="separator:adbb25162f6c4b7b7f6d93381632ab74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970663a099499383430ed58805962679"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a970663a099499383430ed58805962679">PyDoc_STRVAR</a> (cp_SparseVirtualFile_blocks_docstring, &quot;blocks(self) -&gt; typing.Tuple[typing.Tuple[int, int], ...]\n\n&quot; &quot;This returns a ordered tuple ``((file_position, length), ...)``&quot; &quot; of the shape of the blocks held by the SVF in file position order.&quot;)</td></tr>
<tr class="separator:a970663a099499383430ed58805962679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b32cd7bec6df7d3b2a8cabe1402627"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#ae9b32cd7bec6df7d3b2a8cabe1402627">cp_SparseVirtualFile_blocks</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self)</td></tr>
<tr class="separator:ae9b32cd7bec6df7d3b2a8cabe1402627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452756afd943a57da4968fca2b249985"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a452756afd943a57da4968fca2b249985">SVFS_SVF_METHOD_SIZE_T_WRAPPER</a> (block_touch, &quot;Return the latest value of the monotonically increasing block_touch value.&quot;)</td></tr>
<tr class="separator:a452756afd943a57da4968fca2b249985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17458497245c0f563a1c054e45ae08c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#ae17458497245c0f563a1c054e45ae08c">PyDoc_STRVAR</a> (cp_SparseVirtualFile_block_touches_docstring, &quot;block_touches(self) -&gt; typing.Dict[int, int]\n\n&quot; &quot;This returns a dict ``{touch_int: file_position, ...}``&quot; &quot; of the touch integer of each block mapped to the file position.\n&quot; &quot;The caller can decide what older blocks can be used the erase(file_position).&quot;)</td></tr>
<tr class="separator:ae17458497245c0f563a1c054e45ae08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2d11a444d4b6d3ce7984a4d0d01ea6"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a8e2d11a444d4b6d3ce7984a4d0d01ea6">cp_SparseVirtualFile_block_touches</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self)</td></tr>
<tr class="separator:a8e2d11a444d4b6d3ce7984a4d0d01ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b2e841a243b339d34e3f4fdcb8bbdc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#aa3b2e841a243b339d34e3f4fdcb8bbdc">PyDoc_STRVAR</a> (cp_SparseVirtualFile_lru_punt_docstring, &quot;lru_punt(self, cache_size_upper_bound: int) -&gt; int\n\n&quot; &quot;Reduces the size of the cache to &lt; the given size by removing older blocks, at least one block will be left.\n&quot; &quot;There are limitations to this tactic, see the documentation in Technical Notes -&gt; Cache Punting.&quot;)</td></tr>
<tr class="separator:aa3b2e841a243b339d34e3f4fdcb8bbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa516220b91a7d0f0707185d4c438ee51"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#aa516220b91a7d0f0707185d4c438ee51">cp_SparseVirtualFile_lru_punt</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self, PyObject *args, PyObject *kwargs)</td></tr>
<tr class="separator:aa516220b91a7d0f0707185d4c438ee51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e17e53f782895d8fa23b16396a77ad6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a6e17e53f782895d8fa23b16396a77ad6">PyDoc_STRVAR</a> (cp_SparseVirtualFile_file_mod_time_matches_docstring, &quot;file_mod_time_matches(self, file_mod_time: float) -&gt; bool\n\n&quot; &quot;Returns True if the file modification time of the Sparse Virtual File matches the given time as a float.&quot;)</td></tr>
<tr class="separator:a6e17e53f782895d8fa23b16396a77ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7c3a05e30ce11bff5a5ccc7070c499"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a3e7c3a05e30ce11bff5a5ccc7070c499">cp_SparseVirtualFile_file_mod_time_matches</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self, PyObject *args, PyObject *kwargs)</td></tr>
<tr class="separator:a3e7c3a05e30ce11bff5a5ccc7070c499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbe1c77ad9f27b3342778ec55670997"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a9bbe1c77ad9f27b3342778ec55670997">PyDoc_STRVAR</a> (cp_SparseVirtualFile_file_mod_time_docstring, &quot;file_mod_time(self) -&gt; float\n\n&quot; &quot;Returns the file modification time as a float in UNIX time of the Sparse Virtual File.&quot;)</td></tr>
<tr class="separator:a9bbe1c77ad9f27b3342778ec55670997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa925d94c2702ba0e640960d6b64a90c6"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#aa925d94c2702ba0e640960d6b64a90c6">cp_SparseVirtualFile_file_mod_time</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self)</td></tr>
<tr class="separator:aa925d94c2702ba0e640960d6b64a90c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad3f5ed9a3e0a02a7b8a7724eb12dd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#acad3f5ed9a3e0a02a7b8a7724eb12dd2">SVFS_SVF_METHOD_SIZE_T_WRAPPER</a> (count_write, &quot;Returns the count of write operations on the Sparse Virtual File.&quot;)</td></tr>
<tr class="separator:acad3f5ed9a3e0a02a7b8a7724eb12dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a656b2ab882a0965f58b224c6adbb91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a9a656b2ab882a0965f58b224c6adbb91">SVFS_SVF_METHOD_SIZE_T_WRAPPER</a> (count_read, &quot;Returns the count of read operations on the Sparse Virtual File.&quot;)</td></tr>
<tr class="separator:a9a656b2ab882a0965f58b224c6adbb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd2e7a06fb1abeb7bebbab5eae3098d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a1fd2e7a06fb1abeb7bebbab5eae3098d">SVFS_SVF_METHOD_SIZE_T_WRAPPER</a> (bytes_write, &quot;Returns the count of the number of bytes writen to the Sparse Virtual File.&quot;)</td></tr>
<tr class="separator:a1fd2e7a06fb1abeb7bebbab5eae3098d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93a211b8d3049a4ff22113f0d912f92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#ae93a211b8d3049a4ff22113f0d912f92">SVFS_SVF_METHOD_SIZE_T_WRAPPER</a> (bytes_read, &quot;Returns the count of the number of bytes read from the Sparse Virtual File.&quot;)</td></tr>
<tr class="separator:ae93a211b8d3049a4ff22113f0d912f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5329698611ee5cce5047977a66a7349"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#ae5329698611ee5cce5047977a66a7349">PyDoc_STRVAR</a> (cp_SparseVirtualFile_time_write_docstring, &quot;time_write(self) -&gt; typing.Optional[datetime.datetime]\n\n&quot; &quot;Returns the timestamp of the last write to the Sparse Virtual File as a ``datetime.datetime``&quot; &quot; or ``None`` if no write has taken place.&quot;)</td></tr>
<tr class="separator:ae5329698611ee5cce5047977a66a7349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514c4fbc9803a06df7859ff01109e980"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a514c4fbc9803a06df7859ff01109e980">cp_SparseVirtualFile_time_write</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self)</td></tr>
<tr class="separator:a514c4fbc9803a06df7859ff01109e980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbd3b13373d04d4bae5c7bd3937d481"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#aacbd3b13373d04d4bae5c7bd3937d481">PyDoc_STRVAR</a> (cp_SparseVirtualFile_time_read_docstring, &quot;time_read(self) -&gt; typing.Optional[datetime.datetime]\n\n&quot; &quot;Returns the timestamp of the last read from the Sparse Virtual File as a ``datetime.datetime``&quot; &quot; or ``None`` if no read has taken place.&quot;)</td></tr>
<tr class="separator:aacbd3b13373d04d4bae5c7bd3937d481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8281e05b267659e2a14ed4590e3ec519"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a8281e05b267659e2a14ed4590e3ec519">cp_SparseVirtualFile_time_read</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self)</td></tr>
<tr class="separator:a8281e05b267659e2a14ed4590e3ec519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f089d9e9354b0942662e3ec6508cb22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a1f089d9e9354b0942662e3ec6508cb22">PyDoc_STRVAR</a> (cp_SparseVirtualFile_config_docstring, &quot;config(self) -&gt; typing.Dict[str, bool]\n\n&quot; &quot;Returns the SVF configuration as a dict.&quot;)</td></tr>
<tr class="separator:a1f089d9e9354b0942662e3ec6508cb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679cdd1571df8202c4020ab57d6496eb"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a679cdd1571df8202c4020ab57d6496eb">cp_SparseVirtualFile_config</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self)</td></tr>
<tr class="separator:a679cdd1571df8202c4020ab57d6496eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d061a25422de9096ef1cc358ea3e99"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#ad4d061a25422de9096ef1cc358ea3e99">cp_SparseVirtualFile___getstate__</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self, PyObject *Py_UNUSED(ignored))</td></tr>
<tr class="separator:ad4d061a25422de9096ef1cc358ea3e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771f948455bc480256a97f498f75ec8f"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a771f948455bc480256a97f498f75ec8f">cp_SparseVirtualFile___setstate__</a> (<a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *self, PyObject *state)</td></tr>
<tr class="separator:a771f948455bc480256a97f498f75ec8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64de1869514950a178f428a4db3ae9af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a64de1869514950a178f428a4db3ae9af">PyDoc_STRVAR</a> (svfs_cSVF_doc, &quot;This class implements a Sparse Virtual File (SVF).&quot; &quot; This is an in-memory file that has fragments of a real file.&quot; &quot; It has read/write operations and can describe what file fragments are needed, if any, before any read operation.&quot; &quot;\n\n&quot; &quot;The constructor takes a string as an ID and optionally:\n&quot; &quot; - A file modification time as a float (default 0.0).&quot; &quot; This can be used for checking if the actual file might been changed which might invalidate the SVF.\n&quot; &quot; - ``overwrite_on_exit``, a boolean that will overwrite the memory on destruction (default ``False``).&quot; &quot; If ``True`` then ``clear()`` on a 1Mb SVF typically takes 35 µs, if ``False`` 1.5 µs.\n&quot; &quot; - ``compare_for_diff``, a boolean that will check that overlapping writes match (default ``True``).&quot; &quot; If ``True`` this adds about 25% time to an overlapping write but gives better chance of catching changes to the&quot; &quot; original file.\n&quot; &quot;\n\n&quot; &quot;For example::&quot; &quot;\n\n&quot; &quot;       import svfsc\n&quot; &quot;       \n&quot; &quot;       svf = svfsc.cSVF('some ID')\n&quot; &quot;       svf.write(12, b'ABCD')\n&quot; &quot;       svf.read(13, 2)  # Returns b'BC'\n&quot; &quot;       svf.need(10, 12)  # Returns ((10, 2), 16, 6)), the file positions and lengths the the SVF needs\n&quot; &quot;       svf.read(1024, 18)  # SVF raises an error as it has no data here.\n&quot; &quot;\n&quot; &quot;Signature:\n\n``svfsc.cSVF(id: str, mod_time: float = 0.0, overwrite_on_exit: bool = False, compare_for_diff: bool = True)``&quot;)</td></tr>
<tr class="separator:a64de1869514950a178f428a4db3ae9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6612e7e0a7d567d45c414c79a6c0e977"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a6612e7e0a7d567d45c414c79a6c0e977">PICKLE_ID_KEY</a> = &quot;id&quot;</td></tr>
<tr class="separator:a6612e7e0a7d567d45c414c79a6c0e977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6e64de0dfa28991ea7baef8880aadd"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#afc6e64de0dfa28991ea7baef8880aadd">PICKLE_FILE_MOD_TIME_KEY</a> = &quot;file_mod_time&quot;</td></tr>
<tr class="separator:afc6e64de0dfa28991ea7baef8880aadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c4c32ac95208071c60f2766f21efc3"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#ab9c4c32ac95208071c60f2766f21efc3">PICKLE_BLOCKS_KEY</a> = &quot;blocks&quot;</td></tr>
<tr class="separator:ab9c4c32ac95208071c60f2766f21efc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a2f98187c6096ce42a41d579f1ad35"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a16a2f98187c6096ce42a41d579f1ad35">PICKLE_VERSION_KEY</a> = &quot;pickle_version&quot;</td></tr>
<tr class="separator:a16a2f98187c6096ce42a41d579f1ad35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893952899e85919ed3bf199aaaea47ad"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a893952899e85919ed3bf199aaaea47ad">PICKLE_VERSION</a> = 1</td></tr>
<tr class="separator:a893952899e85919ed3bf199aaaea47ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a233cee53bc252f8ada51b71a6b369"><td class="memItemLeft" align="right" valign="top">static PyMemberDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a43a233cee53bc252f8ada51b71a6b369">cp_SparseVirtualFile_members</a> []</td></tr>
<tr class="separator:a43a233cee53bc252f8ada51b71a6b369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c481167b7c72b68498bef53f7897be"><td class="memItemLeft" align="right" valign="top">static PyMethodDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#af4c481167b7c72b68498bef53f7897be">cp_SparseVirtualFile_methods</a> []</td></tr>
<tr class="separator:af4c481167b7c72b68498bef53f7897be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ad45b121bc493e37e2cc9b6f770216"><td class="memItemLeft" align="right" valign="top">static PyTypeObject&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="__c_s_v_f_8cpp.html#a34ad45b121bc493e37e2cc9b6f770216">svfsc_cSVF</a></td></tr>
<tr class="separator:a34ad45b121bc493e37e2cc9b6f770216"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Python wrapper around a C++ SparseVirtualFile.</p>
<p>Naming convention:</p>
<p>SVF functions are named cp_SparseVirtualFile_...</p>
<pre class="fragment">   MIT License

   Copyright (c) 2020-2023 Paul Ross

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
</pre> 
<p class="definition">Definition in file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa4bb1019d146031999de58fff545accc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bb1019d146031999de58fff545accc">&#9670;&nbsp;</a></span>ASSERT_FUNCTION_ENTRY_SVF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ASSERT_FUNCTION_ENTRY_SVF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">member</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> { \</div>
<div class="line">    assert(<span class="keyword">self</span>); \</div>
<div class="line">    assert(((<a class="code" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *)<span class="keyword">self</span>)-&gt;member); \</div>
<div class="line">    assert(! PyErr_Occurred()); \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="astructcp___sparse_virtual_file_html"><div class="ttname"><a href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a></div><div class="ttdoc">Python wrapper around a C++ SparseVirtualFile.</div><div class="ttdef"><b>Definition:</b> <a href="__c_s_v_f_8cpp_source.html#l00090">_cSVF.cpp:90</a></div></div>
</div><!-- fragment --><p>Function entry point test macro. After construction, we expect this invariant at the entry to each function. The cast is necessary when used with functions that take a <code><a class="el" href="namespace_s_v_f_s.html" title="The namespace for all svfsc code.">SVFS</a></code> as a <code>PyObject*</code> such as cp_SparseVirtualFile_mapping_length </p>

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00150">150</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="af631b17b1e5840bc33df4bbe08dbcbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af631b17b1e5840bc33df4bbe08dbcbbb">&#9670;&nbsp;</a></span>SVFS_SVF_METHOD_SIZE_T_WRAPPER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVFS_SVF_METHOD_SIZE_T_WRAPPER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">method_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">docstring&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="__c_s_v_f_8cpp.html#af76f2ef83d2a9d4704e1e980e2a4d087">PyDoc_STRVAR</a>(                                                  \</div>
<div class="line">    cp_SparseVirtualFile_##method_name##_docstring,            \</div>
<div class="line">    #method_name<span class="stringliteral">&quot;(self) -&gt; int\n\n&quot;</span>                                \</div>
<div class="line">    docstring                                                  \</div>
<div class="line">);\</div>
<div class="line">static PyObject * \</div>
<div class="line">cp_SparseVirtualFile_##method_name(<a class="code" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *<span class="keyword">self</span>) { \</div>
<div class="line">    ASSERT_FUNCTION_ENTRY_SVF(pSvf); \</div>
<div class="line">    PyObject *ret = NULL; \</div>
<div class="line">    try { \</div>
<div class="line">        ret = PyLong_FromLong(self-&gt;pSvf-&gt;method_name()); \</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception &amp;err) { \</div>
<div class="line">        PyErr_Format(PyExc_RuntimeError, <span class="stringliteral">&quot;%s: FATAL caught std::exception %s&quot;</span>, __FUNCTION__, err.what()); \</div>
<div class="line">        goto except; \</div>
<div class="line">    } \</div>
<div class="line">    assert(! PyErr_Occurred()); \</div>
<div class="line">    assert(ret); \</div>
<div class="line">    goto <span class="keywordflow">finally</span>; \</div>
<div class="line">except: \</div>
<div class="line">    assert(PyErr_Occurred()); \</div>
<div class="line">    Py_XDECREF(ret); \</div>
<div class="line">    ret = NULL; \</div>
<div class="line">finally: \</div>
<div class="line">    return ret; \</div>
<div class="line">}</div>
<div class="ttc" id="a__c_s_v_f_8cpp_html_af76f2ef83d2a9d4704e1e980e2a4d087"><div class="ttname"><a href="__c_s_v_f_8cpp.html#af76f2ef83d2a9d4704e1e980e2a4d087">PyDoc_STRVAR</a></div><div class="ttdeci">PyDoc_STRVAR(cp_SparseVirtualFile_id_docstring, &quot;id(self) -&gt; str\n\n&quot; &quot;Returns the ID of the Sparse Virtual File.&quot;)</div></div>
</div><!-- fragment --><p>TODO: Implement the Buffer Protocol rather than returning a copy of the bytes? Look for PyBytes_FromStringAndSize(). This macro is for functions that return a size_t type such as count_write, count_read, bytes_write, bytes_read.</p>
<p>Usage:</p>
<p>PyDoc_STRVAR( cp_SparseVirtualFile_count_write_docstring, "count_write(self) -&gt; int\n\n" "Returns the count of write operations on the Sparse Virtual File." );</p>
<p>Perhaps ret = Py_BuildValue("K", self-&gt;pSvf-&gt;method_name()); </p>

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00058">58</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad4d061a25422de9096ef1cc358ea3e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d061a25422de9096ef1cc358ea3e99">&#9670;&nbsp;</a></span>cp_SparseVirtualFile___getstate__()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile___getstate__ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>Py_UNUSED</em>ignored&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a Python dict suitable for pickling. Key/values are: id, file_mod_time, list_of_file_pos/bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td></td></tr>
    <tr><td class="paramname">_unused_ignored</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l01030">1030</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a771f948455bc480256a97f498f75ec8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771f948455bc480256a97f498f75ec8f">&#9670;&nbsp;</a></span>cp_SparseVirtualFile___setstate__()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile___setstate__ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l01082">1082</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a8e2d11a444d4b6d3ce7984a4d0d01ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2d11a444d4b6d3ce7984a4d0d01ea6">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_block_touches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_block_touches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00701">701</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="ae9b32cd7bec6df7d3b2a8cabe1402627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b32cd7bec6df7d3b2a8cabe1402627">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_blocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00644">644</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a679cdd1571df8202c4020ab57d6496eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679cdd1571df8202c4020ab57d6496eb">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_config()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00998">998</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a147fa3eb67dd4958d0da4813beba9b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147fa3eb67dd4958d0da4813beba9b17">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_dealloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cp_SparseVirtualFile_dealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocate the SparseVirtualFile. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The Python SparseVirtualFile. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00255">255</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a425ca0f68fffc47749ec6653d2ecafcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425ca0f68fffc47749ec6653d2ecafcd">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_erase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00503">503</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="aa925d94c2702ba0e640960d6b64a90c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa925d94c2702ba0e640960d6b64a90c6">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_file_mod_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_file_mod_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00858">858</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a3e7c3a05e30ce11bff5a5ccc7070c499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7c3a05e30ce11bff5a5ccc7070c499">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_file_mod_time_matches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_file_mod_time_matches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00804">804</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="aaaecc0b011d5e60bb958e1841bbc3f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaecc0b011d5e60bb958e1841bbc3f03">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_has_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_has_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00337">337</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a5afd8d13ca7aa1f150f391d4e772c765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afd8d13ca7aa1f150f391d4e772c765">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00279">279</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="ab1106f66d8bdca88bfdf3b42bfaaa0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1106f66d8bdca88bfdf3b42bfaaa0c2">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int cp_SparseVirtualFile_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialise the <a class="el" href="structcp___sparse_virtual_file.html" title="Python wrapper around a C++ SparseVirtualFile.">cp_SparseVirtualFile</a>.</p>
<p>See the defaults for <a class="el" href="struct_s_v_f_s_1_1_sparse_virtual_file_config.html" title="Configuration for the Sparse Virtual File.">SVFS::SparseVirtualFileConfig</a> for how that works.</p>
<p>Arguments/keywords:</p>
<ul>
<li><code>id</code> Mandatory, str, ID.</li>
<li><code>mod_time</code> Optional, float, modification time, defaults to 0.0</li>
<li><code>overwrite_on_exit</code> Optional, bool, See the defaults for <a class="el" href="struct_s_v_f_s_1_1_sparse_virtual_file_config.html" title="Configuration for the Sparse Virtual File.">SVFS::SparseVirtualFileConfig</a></li>
<li><code>compare_for_diff</code> Optional, bool, See the defaults for <a class="el" href="struct_s_v_f_s_1_1_sparse_virtual_file_config.html" title="Configuration for the Sparse Virtual File.">SVFS::SparseVirtualFileConfig</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The <a class="el" href="structcp___sparse_virtual_file.html" title="Python wrapper around a C++ SparseVirtualFile.">cp_SparseVirtualFile</a>. </td></tr>
    <tr><td class="paramname">args</td><td>Order: "id", "mod_time", "overwrite_on_exit", "compare_for_diff". </td></tr>
    <tr><td class="paramname">kwargs</td><td>Can be "id", "mod_time", "overwrite_on_exit", "compare_for_diff". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, non-zero on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00204">204</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="aa516220b91a7d0f0707185d4c438ee51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa516220b91a7d0f0707185d4c438ee51">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_lru_punt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_lru_punt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See cp_SparseVirtualFile_lru_punt_docstring</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The <a class="el" href="structcp___sparse_virtual_file.html" title="Python wrapper around a C++ SparseVirtualFile.">cp_SparseVirtualFile</a> </td></tr>
    <tr><td class="paramname">args</td><td>The upper bound of the number of bytes held by the cache. </td></tr>
    <tr><td class="paramname">kwargs</td><td>"cache_size_upper_bound". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00765">765</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="adbb25162f6c4b7b7f6d93381632ab74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb25162f6c4b7b7f6d93381632ab74a">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_need()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_need </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See cp_SparseVirtualFile_need_docstring</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The <a class="el" href="structcp___sparse_virtual_file.html" title="Python wrapper around a C++ SparseVirtualFile.">cp_SparseVirtualFile</a> </td></tr>
    <tr><td class="paramname">args</td><td>The file_position and length. Optionally a greedy_length. </td></tr>
    <tr><td class="paramname">kwargs</td><td>"file_position", "length", "greedy_length". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of tuples (file_position, length). </dd></dl>

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00567">567</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a5781c10b8d991ef69592569ae4267d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5781c10b8d991ef69592569ae4267d15">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_new </td>
          <td>(</td>
          <td class="paramtype">PyTypeObject *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>Py_UNUSED</em>args, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>Py_UNUSED</em>kwds&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Python <code><b>new</b></code>() for a <code><a class="el" href="structcp___sparse_virtual_file.html" title="Python wrapper around a C++ SparseVirtualFile.">cp_SparseVirtualFile</a></code>. Contents will be <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <a class="el" href="structcp___sparse_virtual_file.html" title="Python wrapper around a C++ SparseVirtualFile.">cp_SparseVirtualFile</a> type. </td></tr>
    <tr><td class="paramname">_unused_args</td><td>Unused. </td></tr>
    <tr><td class="paramname">_unused_kwds</td><td>Unused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An empty <a class="el" href="structcp___sparse_virtual_file.html" title="Python wrapper around a C++ SparseVirtualFile.">cp_SparseVirtualFile</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00170">170</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a623988da94f7f5d587bbd2bd9bc77209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623988da94f7f5d587bbd2bd9bc77209">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00465">465</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a8281e05b267659e2a14ed4590e3ec519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8281e05b267659e2a14ed4590e3ec519">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_time_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_time_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00955">955</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a514c4fbc9803a06df7859ff01109e980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514c4fbc9803a06df7859ff01109e980">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_time_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_time_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00910">910</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a2bda1aff1ac4be7170f7ca4225ce5d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bda1aff1ac4be7170f7ca4225ce5d72">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* cp_SparseVirtualFile_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00382">382</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a05c3a042105cc16cf80d25e729395aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c3a042105cc16cf80d25e729395aad">&#9670;&nbsp;</a></span>private_SparseVirtualFile_svf_read_as_py_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject* private_SparseVirtualFile_svf_read_as_py_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>fpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l00435">435</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="ae17458497245c0f563a1c054e45ae08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17458497245c0f563a1c054e45ae08c">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_block_touches_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;block_touches(self) -&gt; typing.Dict\n\n&quot; &quot;This returns a dict ``{touch_int: file_position, ...}``&quot; &quot; of the touch integer of each block mapped to the file position.\n&quot; &quot;The caller can decide what older blocks can be used the erase(file_position).&quot;&#160;</td>
          <td class="paramname">[int, int]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a970663a099499383430ed58805962679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970663a099499383430ed58805962679">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_blocks_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;blocks(self) -&gt; typing.&#160;</td>
          <td class="paramname"><em>Tuple</em>[typing.Tuple[int, int], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">...]\n\n&quot; &quot;This returns a ordered tuple ``((file_position, length),...)``&quot; &quot; of the shape of the blocks held by the SVF in file position order.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>-&mdash; Meta information about the SVF -&mdash; The existing blocks. t_seek_reads blocks() const noexcept;</p>
<p>Information about memory used: size_of() gives best guess of total memory usage. size_t size_of() const noexcept;</p>
<p>Gives exact number of data bytes held. size_t num_bytes() const noexcept { return m_bytes_total; };</p>
<p>Gives exact number of blocks used. size_t num_blocks() const noexcept { return m_svf.size(); } t_fpos last_file_position() const noexcept;</p>
<p>Check the clients file modification time has changed. Caller has to decide what to do... bool file_mod_time_matches(const double &amp;file_mod_time) const noexcept { return file_mod_time == m_file_mod_time; } </p>

</div>
</div>
<a id="a1f089d9e9354b0942662e3ec6508cb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f089d9e9354b0942662e3ec6508cb22">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_config_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;config(self) -&gt; typing.Dict\n\n&quot; &quot;Returns the SVF configuration as a dict.&quot;&#160;</td>
          <td class="paramname">[str, bool]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8cb8195fbc1ad7da04aa79dc2f4d432d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb8195fbc1ad7da04aa79dc2f4d432d">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_erase_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;erase(self, file_position: int) -&gt; None\n\n&quot; &quot;Erase the data from the Sparse Virtual File at the given ``file_position``&quot; &quot; which must be the beginning of a block.\n&quot; &quot;This will raise an ``IOError`` if a block is not present at that file position.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bbe1c77ad9f27b3342778ec55670997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbe1c77ad9f27b3342778ec55670997">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_file_mod_time_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;file_mod_time(self) -&gt; float\n\n&quot; &quot;Returns the file modification time as a float in UNIX time of the Sparse Virtual File.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>-&mdash; Attribute access -&mdash; const std::string id() const noexcept { return m_id; } double file_mod_time() const noexcept { return m_file_mod_time; }</p>
<p>size_t count_write() const noexcept { return m_count_write; } size_t count_read() const noexcept { return m_count_read; } size_t bytes_write() const noexcept { return m_bytes_write; } size_t bytes_read() const noexcept { return m_bytes_read; }</p>
<p>std::chrono::time_point&lt;std::chrono::system_clock&gt; time_write() const noexcept { return m_time_write; } std::chrono::time_point&lt;std::chrono::system_clock&gt; time_read() const noexcept { return m_time_read; } </p>

</div>
</div>
<a id="a6e17e53f782895d8fa23b16396a77ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e17e53f782895d8fa23b16396a77ad6">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_file_mod_time_matches_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;file_mod_time_matches(self, file_mod_time: float) -&gt; bool\n\n&quot; &quot;Returns True if the file modification time of the Sparse Virtual File matches the given time as a float.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0983ec9ed5b3d32bfa17db098f581486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0983ec9ed5b3d32bfa17db098f581486">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_has_data_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;has_data(self, file_position: int, length: int) -&gt; bool\n\n&quot; &quot;Checks if the Sparse Virtual File of the ID has data at the given ``file_position`` and ``length``.\n\n&quot; &quot;Parameters\n\n&quot; &quot;file_position: int\n&quot; &quot; The absolute file position of the start of the data.\n\n&quot; &quot;length: int\n&quot; &quot; The length of the required data in bytes.\n\n&quot; &quot;Returns\n\n&quot; &quot;bool: True if the SVF contains the&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">False otherwise.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af76f2ef83d2a9d4704e1e980e2a4d087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76f2ef83d2a9d4704e1e980e2a4d087">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_id_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;id(self) -&gt; str\n\n&quot; &quot;Returns the ID of the Sparse Virtual File.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3b2e841a243b339d34e3f4fdcb8bbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b2e841a243b339d34e3f4fdcb8bbdc">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_lru_punt_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;lru_punt(self, cache_size_upper_bound: int) -&gt; int\n\n&quot; &quot;Reduces the size of the cache to &lt; the given size by removing older blocks, at least one block will be left.\n&quot; &quot;There are limitations to this tactic, see the documentation in Technical Notes -&gt; Cache Punting.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a507ad11800c262a3d89eeaccfcea7131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507ad11800c262a3d89eeaccfcea7131">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_need_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;need(self, file_position: int, length: int, greedy_length: int = 0) -&gt; typing.&#160;</td>
          <td class="paramname"><em>Tuple</em>[typing.Tuple[int, int], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">...]\n\n&quot; &quot;Given a file_position and length this returns a ordered list ```` of seek/read&quot; &quot; instructions of data that is required to be written to the Sparse Virtual File so that a subsequent read will&quot; &quot; succeed.\n&quot; &quot; If greedy_length&#160;</td>
          <td class="paramname"><em>is</em>[(file_position, length),...], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname"><em>then</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">if&#160;</td>
          <td class="paramname"><em>possible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blocks will be coalesced to reduce the size of the return value.&quot; &quot;\n\n&quot; &quot;.. warning::\n&quot; &quot; The SVF has no knowledge of the the actual file size so when using a greedy length the need list might&quot; &quot; include positions beyond EOF.\n\n&quot; &quot; For example a file 1024 bytes long and a greedy length of 256 then ``need(1000, 24, 256)`` will create&quot; &quot; a need list of ````.&quot; &quot; This should generate a ``write(1000, 24)`` not a ``write(1000, 256)``.\n\n&quot; &quot; It is up to the caller to handle&#160;</td>
          <td class="paramname"><em>this</em>[(1000, 256),], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">however&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">``reads()`` in C/C++/Python will ignore read lengths past&quot; &quot; EOF so the caller does not have to do anything.\n\n&quot; &quot;\n\nUsage::\n\n&quot; &quot; if not svf.has_data(position, length):\n&quot; &quot; for&#160;</td>
          <td class="paramname"><em>read_fpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">read_length in svf.need(position, length):\n&quot; &quot; # Somehow get data as a bytes object at&#160;</td>
          <td class="paramname"><em>read_fpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">read_length...\n&quot; &quot; svf.write(read_fpos, data)\n&quot; &quot; return svf.read(position, length):\n&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae56a02b2bcbed1e96aac28ccd1f8a3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56a02b2bcbed1e96aac28ccd1f8a3ac">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_read_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;read(self, file_position: int, length: int) -&gt; bytes\n\n&quot; &quot;Read the data from the Sparse Virtual File at ``file_position`` and ``length`` returning a ``bytes`` object.&quot; &quot; This takes a file position and a length.&quot; &quot; This will raise an ``IOError`` if any data is not present&quot; &quot; This will raise a ``RuntimeError`` if the data can not be read for any other reason&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacbd3b13373d04d4bae5c7bd3937d481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbd3b13373d04d4bae5c7bd3937d481">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_time_read_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;time_read(self) -&gt; typing.Optional\n\n&quot; &quot;Returns the timestamp of the last read from the Sparse Virtual File as a ``datetime.datetime``&quot; &quot; or ``None`` if no read has taken place.&quot;&#160;</td>
          <td class="paramname">[datetime.datetime]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5329698611ee5cce5047977a66a7349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5329698611ee5cce5047977a66a7349">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_time_write_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;time_write(self) -&gt; typing.Optional\n\n&quot; &quot;Returns the timestamp of the last write to the Sparse Virtual File as a ``datetime.datetime``&quot; &quot; or ``None`` if no write has taken place.&quot;&#160;</td>
          <td class="paramname">[datetime.datetime]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37067b0baf903304708173b2f6fb8ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37067b0baf903304708173b2f6fb8ff2">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">cp_SparseVirtualFile_write_docstring&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;write(self, file_position: int, data: bytes) -&gt; None\n\n&quot; &quot;Writes the data to the Sparse Virtual File of the given ID at ``file_position`` and ``data`` as a ``bytes`` object.&quot; &quot; This will raise an ``IOError`` if ``self.compare_for_diff`` is True and given data is different than&quot; &quot; that seen before and only new data up to this point will be written.&quot; &quot; If the ``byte`` data is empty nothing will be done.&quot; &quot; This will raise a RuntimeError if the data can not be written for any other reason&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64de1869514950a178f428a4db3ae9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64de1869514950a178f428a4db3ae9af">&#9670;&nbsp;</a></span>PyDoc_STRVAR() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">svfs_cSVF_doc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;This class implements a Sparse Virtual File (SVF).&quot; &quot; This is an in-memory file that has fragments of a real file.&quot; &quot; It has read/write operations and can describe what file fragments are&#160;</td>
          <td class="paramname"><em>needed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">if&#160;</td>
          <td class="paramname"><em>any</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">before any read operation.&quot; &quot;\n\n&quot; &quot;The constructor takes a string as an ID and optionally:\n&quot; &quot; - A file modification time as a float(default 0.0).&quot; &quot; This can be used for checking if the actual file might been changed which might invalidate the SVF.\n&quot; &quot; - ``overwrite_on_exit``&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a boolean that will overwrite the memory on destruction(default ``False``).&quot; &quot; If ``True`` then ``clear()`` on a 1Mb SVF typically takes 35&#160;</td>
          <td class="paramname"><em>µs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">if ``False`` 1.5 µs.\n&quot; &quot; - ``compare_for_diff``&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a boolean that will check that overlapping writes match(default ``True``).&quot; &quot; If ``True`` this adds about 25% time to an overlapping write but gives better chance of catching changes to the&quot; &quot; original file.\n&quot; &quot;\n\n&quot; &quot;For example::&quot; &quot;\n\n&quot; &quot; import svfsc\n&quot; &quot; \n&quot; &quot;&#160;</td>
          <td class="paramname"><em>svf</em> = <code>svfsc.cSVF('some&#160;ID')\n&quot;&#160;&quot;&#160;&#160;&#160;&#160;&#160;&#160;&#160;svf.write(12,&#160;b'ABCD')\n&quot;&#160;&quot;&#160;&#160;&#160;&#160;&#160;&#160;&#160;svf.read(13,&#160;2)&#160;&#160;#&#160;Returns&#160;b'BC'\n&quot;&#160;&quot;&#160;&#160;&#160;&#160;&#160;&#160;&#160;svf.need(10,&#160;12)&#160;&#160;#&#160;Returns&#160;((10,&#160;2),&#160;16,&#160;6)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a452756afd943a57da4968fca2b249985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452756afd943a57da4968fca2b249985">&#9670;&nbsp;</a></span>SVFS_SVF_METHOD_SIZE_T_WRAPPER() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SVFS_SVF_METHOD_SIZE_T_WRAPPER </td>
          <td>(</td>
          <td class="paramtype">block_touch&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Return the latest value of the monotonically increasing block_touch value.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae93a211b8d3049a4ff22113f0d912f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93a211b8d3049a4ff22113f0d912f92">&#9670;&nbsp;</a></span>SVFS_SVF_METHOD_SIZE_T_WRAPPER() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SVFS_SVF_METHOD_SIZE_T_WRAPPER </td>
          <td>(</td>
          <td class="paramtype">bytes_read&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Returns the count of the number of bytes read from the Sparse Virtual File.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fd2e7a06fb1abeb7bebbab5eae3098d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd2e7a06fb1abeb7bebbab5eae3098d">&#9670;&nbsp;</a></span>SVFS_SVF_METHOD_SIZE_T_WRAPPER() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SVFS_SVF_METHOD_SIZE_T_WRAPPER </td>
          <td>(</td>
          <td class="paramtype">bytes_write&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Returns the count of the number of bytes writen to the Sparse Virtual File.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a656b2ab882a0965f58b224c6adbb91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a656b2ab882a0965f58b224c6adbb91">&#9670;&nbsp;</a></span>SVFS_SVF_METHOD_SIZE_T_WRAPPER() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SVFS_SVF_METHOD_SIZE_T_WRAPPER </td>
          <td>(</td>
          <td class="paramtype">count_read&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Returns the count of read operations on the Sparse Virtual File.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acad3f5ed9a3e0a02a7b8a7724eb12dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad3f5ed9a3e0a02a7b8a7724eb12dd2">&#9670;&nbsp;</a></span>SVFS_SVF_METHOD_SIZE_T_WRAPPER() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SVFS_SVF_METHOD_SIZE_T_WRAPPER </td>
          <td>(</td>
          <td class="paramtype">count_write&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Returns the count of write operations on the Sparse Virtual File.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad043247e943996f4582b53867bce9da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad043247e943996f4582b53867bce9da5">&#9670;&nbsp;</a></span>SVFS_SVF_METHOD_SIZE_T_WRAPPER() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SVFS_SVF_METHOD_SIZE_T_WRAPPER </td>
          <td>(</td>
          <td class="paramtype">last_file_position&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Returns the file position immediately past the last block.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad851e5570f4f97c4d61ef75da3673cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad851e5570f4f97c4d61ef75da3673cac">&#9670;&nbsp;</a></span>SVFS_SVF_METHOD_SIZE_T_WRAPPER() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SVFS_SVF_METHOD_SIZE_T_WRAPPER </td>
          <td>(</td>
          <td class="paramtype">num_blocks&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Returns the total number of blocks of data held by the Sparse Virtual File System.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2db3591d2119af3833b31973a786c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2db3591d2119af3833b31973a786c39">&#9670;&nbsp;</a></span>SVFS_SVF_METHOD_SIZE_T_WRAPPER() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SVFS_SVF_METHOD_SIZE_T_WRAPPER </td>
          <td>(</td>
          <td class="paramtype">num_bytes&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Returns the total number of file bytes held by the Sparse Virtual File.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bc10e80de31d5e1174b7779da24437a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc10e80de31d5e1174b7779da24437a">&#9670;&nbsp;</a></span>SVFS_SVF_METHOD_SIZE_T_WRAPPER() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SVFS_SVF_METHOD_SIZE_T_WRAPPER </td>
          <td>(</td>
          <td class="paramtype">size_of&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Returns the estimate of total memory usage of the Sparse Virtual File.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a43a233cee53bc252f8ada51b71a6b369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a233cee53bc252f8ada51b71a6b369">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_members</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PyMemberDef cp_SparseVirtualFile_members[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        {NULL, 0, 0, 0, NULL}  </div>
<div class="line">}</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l01194">1194</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="af4c481167b7c72b68498bef53f7897be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c481167b7c72b68498bef53f7897be">&#9670;&nbsp;</a></span>cp_SparseVirtualFile_methods</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PyMethodDef cp_SparseVirtualFile_methods[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l01200">1200</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="ab9c4c32ac95208071c60f2766f21efc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c4c32ac95208071c60f2766f21efc3">&#9670;&nbsp;</a></span>PICKLE_BLOCKS_KEY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* PICKLE_BLOCKS_KEY = &quot;blocks&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l01017">1017</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="afc6e64de0dfa28991ea7baef8880aadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6e64de0dfa28991ea7baef8880aadd">&#9670;&nbsp;</a></span>PICKLE_FILE_MOD_TIME_KEY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* PICKLE_FILE_MOD_TIME_KEY = &quot;file_mod_time&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l01016">1016</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a6612e7e0a7d567d45c414c79a6c0e977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6612e7e0a7d567d45c414c79a6c0e977">&#9670;&nbsp;</a></span>PICKLE_ID_KEY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* PICKLE_ID_KEY = &quot;id&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l01015">1015</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a893952899e85919ed3bf199aaaea47ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893952899e85919ed3bf199aaaea47ad">&#9670;&nbsp;</a></span>PICKLE_VERSION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PICKLE_VERSION = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l01019">1019</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a16a2f98187c6096ce42a41d579f1ad35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a2f98187c6096ce42a41d579f1ad35">&#9670;&nbsp;</a></span>PICKLE_VERSION_KEY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* PICKLE_VERSION_KEY = &quot;pickle_version&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l01018">1018</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
<a id="a34ad45b121bc493e37e2cc9b6f770216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ad45b121bc493e37e2cc9b6f770216">&#9670;&nbsp;</a></span>svfsc_cSVF</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PyTypeObject svfsc_cSVF</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        PyVarObject_HEAD_INIT(NULL, 0)</div>
<div class="line">        .tp_name = <span class="stringliteral">&quot;svfsc.cSVF&quot;</span>,</div>
<div class="line">        .tp_basicsize = <span class="keyword">sizeof</span>(<a class="code" href="structcp___sparse_virtual_file.html">cp_SparseVirtualFile</a>),</div>
<div class="line">        .tp_itemsize = 0,</div>
<div class="line">        .tp_dealloc = (destructor) <a class="code" href="__c_s_v_f_8cpp.html#a147fa3eb67dd4958d0da4813beba9b17">cp_SparseVirtualFile_dealloc</a>,</div>
<div class="line">        .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,</div>
<div class="line">        .tp_doc = svfs_cSVF_doc,</div>
<div class="line">        .tp_methods = <a class="code" href="__c_s_v_f_8cpp.html#af4c481167b7c72b68498bef53f7897be">cp_SparseVirtualFile_methods</a>,</div>
<div class="line">        .tp_members = <a class="code" href="__c_s_v_f_8cpp.html#a43a233cee53bc252f8ada51b71a6b369">cp_SparseVirtualFile_members</a>,</div>
<div class="line">        .tp_init = (initproc) <a class="code" href="__c_s_v_f_8cpp.html#ab1106f66d8bdca88bfdf3b42bfaaa0c2">cp_SparseVirtualFile_init</a>,</div>
<div class="line">        .tp_new = <a class="code" href="__c_s_v_f_8cpp.html#a5781c10b8d991ef69592569ae4267d15">cp_SparseVirtualFile_new</a>,</div>
<div class="line">}</div>
<div class="ttc" id="a__c_s_v_f_8cpp_html_a147fa3eb67dd4958d0da4813beba9b17"><div class="ttname"><a href="__c_s_v_f_8cpp.html#a147fa3eb67dd4958d0da4813beba9b17">cp_SparseVirtualFile_dealloc</a></div><div class="ttdeci">static void cp_SparseVirtualFile_dealloc(cp_SparseVirtualFile *self)</div><div class="ttdef"><b>Definition:</b> <a href="__c_s_v_f_8cpp_source.html#l00255">_cSVF.cpp:255</a></div></div>
<div class="ttc" id="a__c_s_v_f_8cpp_html_a43a233cee53bc252f8ada51b71a6b369"><div class="ttname"><a href="__c_s_v_f_8cpp.html#a43a233cee53bc252f8ada51b71a6b369">cp_SparseVirtualFile_members</a></div><div class="ttdeci">static PyMemberDef cp_SparseVirtualFile_members[]</div><div class="ttdef"><b>Definition:</b> <a href="__c_s_v_f_8cpp_source.html#l01194">_cSVF.cpp:1194</a></div></div>
<div class="ttc" id="a__c_s_v_f_8cpp_html_a5781c10b8d991ef69592569ae4267d15"><div class="ttname"><a href="__c_s_v_f_8cpp.html#a5781c10b8d991ef69592569ae4267d15">cp_SparseVirtualFile_new</a></div><div class="ttdeci">static PyObject * cp_SparseVirtualFile_new(PyTypeObject *type, PyObject *Py_UNUSED(args), PyObject *Py_UNUSED(kwds))</div><div class="ttdef"><b>Definition:</b> <a href="__c_s_v_f_8cpp_source.html#l00170">_cSVF.cpp:170</a></div></div>
<div class="ttc" id="a__c_s_v_f_8cpp_html_ab1106f66d8bdca88bfdf3b42bfaaa0c2"><div class="ttname"><a href="__c_s_v_f_8cpp.html#ab1106f66d8bdca88bfdf3b42bfaaa0c2">cp_SparseVirtualFile_init</a></div><div class="ttdeci">static int cp_SparseVirtualFile_init(cp_SparseVirtualFile *self, PyObject *args, PyObject *kwargs)</div><div class="ttdef"><b>Definition:</b> <a href="__c_s_v_f_8cpp_source.html#l00204">_cSVF.cpp:204</a></div></div>
<div class="ttc" id="a__c_s_v_f_8cpp_html_af4c481167b7c72b68498bef53f7897be"><div class="ttname"><a href="__c_s_v_f_8cpp.html#af4c481167b7c72b68498bef53f7897be">cp_SparseVirtualFile_methods</a></div><div class="ttdeci">static PyMethodDef cp_SparseVirtualFile_methods[]</div><div class="ttdef"><b>Definition:</b> <a href="__c_s_v_f_8cpp_source.html#l01200">_cSVF.cpp:1200</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="__c_s_v_f_8cpp_source.html#l01349">1349</a> of file <a class="el" href="__c_s_v_f_8cpp_source.html">_cSVF.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
