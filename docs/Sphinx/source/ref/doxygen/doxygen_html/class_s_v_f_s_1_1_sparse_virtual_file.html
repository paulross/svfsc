<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sparse Virtual File System: SVFS::SparseVirtualFile Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sparse Virtual File System
   &#160;<span id="projectnumber">0.4.0</span>
   </div>
   <div id="projectbrief">A Sparse Virtual File System.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_s_v_f_s.html">SVFS</a></li><li class="navelem"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html">SparseVirtualFile</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_s_v_f_s_1_1_sparse_virtual_file-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SVFS::SparseVirtualFile Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of a <em>Sparse Virtual File</em>.  
 <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="svf_8h_source.html">svf.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_v_f_s_1_1_sparse_virtual_file_1_1t__val.html">t_val</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the data. This allows for extra per-block fields in the future.  <a href="struct_s_v_f_s_1_1_sparse_virtual_file_1_1t__val.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5238b80ed9e7ed3421e74b3d492dba94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5238b80ed9e7ed3421e74b3d492dba94">SparseVirtualFile</a> (const std::string &amp;<a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a47dba399c3b8d0b5c56c2053455132d7">id</a>, double mod_time, const <a class="el" href="namespace_s_v_f_s.html#a1eab55d2643d9e51c4f4595b78afe9af">tSparseVirtualFileConfig</a> &amp;<a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5f7d0ea05d7a27e94ffbb3a74cb8d150">config</a>=<a class="el" href="namespace_s_v_f_s.html#a1eab55d2643d9e51c4f4595b78afe9af">tSparseVirtualFileConfig</a>())</td></tr>
<tr class="memdesc:a5238b80ed9e7ed3421e74b3d492dba94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Sparse Virtual File.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5238b80ed9e7ed3421e74b3d492dba94">More...</a><br /></td></tr>
<tr class="separator:a5238b80ed9e7ed3421e74b3d492dba94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88502c3064a53388db887e176c9ba07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#aa88502c3064a53388db887e176c9ba07">has</a> (<a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> fpos, size_t len) const noexcept</td></tr>
<tr class="memdesc:aa88502c3064a53388db887e176c9ba07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do I have the data at the given file position and length?  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#aa88502c3064a53388db887e176c9ba07">More...</a><br /></td></tr>
<tr class="separator:aa88502c3064a53388db887e176c9ba07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae9a0a31892a3b41581ab888dd1323c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5ae9a0a31892a3b41581ab888dd1323c">write</a> (<a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> fpos, const char *data, size_t len)</td></tr>
<tr class="memdesc:a5ae9a0a31892a3b41581ab888dd1323c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data a the given file position.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5ae9a0a31892a3b41581ab888dd1323c">More...</a><br /></td></tr>
<tr class="separator:a5ae9a0a31892a3b41581ab888dd1323c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92b513994c68322312358db4197ac94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad92b513994c68322312358db4197ac94">read</a> (<a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> fpos, size_t len, char *p)</td></tr>
<tr class="memdesc:ad92b513994c68322312358db4197ac94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data and write to the buffer provided by the caller. This is non-const as it updates the non-const members such as <code>m_block_touch</code> etc.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad92b513994c68322312358db4197ac94">More...</a><br /></td></tr>
<tr class="separator:ad92b513994c68322312358db4197ac94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade33f55fdcee892fbc10a44aa219b6c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ade33f55fdcee892fbc10a44aa219b6c5">need</a> (<a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> fpos, size_t len, size_t greedy_length=0) const noexcept</td></tr>
<tr class="memdesc:ade33f55fdcee892fbc10a44aa219b6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new fragmentation list of seek/read instructions.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#ade33f55fdcee892fbc10a44aa219b6c5">More...</a><br /></td></tr>
<tr class="separator:ade33f55fdcee892fbc10a44aa219b6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a687c5d6ccbc55dcee600eaf5e6e9b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a1a687c5d6ccbc55dcee600eaf5e6e9b7">need_many</a> (<a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a> &amp;seek_reads, size_t greedy_length=0) const noexcept</td></tr>
<tr class="memdesc:a1a687c5d6ccbc55dcee600eaf5e6e9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given many [(file position, lengths), ...] what data do I need that I don't yet have?  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a1a687c5d6ccbc55dcee600eaf5e6e9b7">More...</a><br /></td></tr>
<tr class="separator:a1a687c5d6ccbc55dcee600eaf5e6e9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60494f093b0d344c2287564a6e0c053d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a60494f093b0d344c2287564a6e0c053d">clear</a> () noexcept</td></tr>
<tr class="memdesc:a60494f093b0d344c2287564a6e0c053d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the data deletion strategy.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a60494f093b0d344c2287564a6e0c053d">More...</a><br /></td></tr>
<tr class="separator:a60494f093b0d344c2287564a6e0c053d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ffb36bd3061ea6e08fe2bbb72b5e32"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a92ffb36bd3061ea6e08fe2bbb72b5e32">erase</a> (<a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> fpos)</td></tr>
<tr class="memdesc:a92ffb36bd3061ea6e08fe2bbb72b5e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a particular block.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a92ffb36bd3061ea6e08fe2bbb72b5e32">More...</a><br /></td></tr>
<tr class="separator:a92ffb36bd3061ea6e08fe2bbb72b5e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcb4ccea430a954d95502399306e771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#aebcb4ccea430a954d95502399306e771">blocks</a> () const noexcept</td></tr>
<tr class="memdesc:aebcb4ccea430a954d95502399306e771"><td class="mdescLeft">&#160;</td><td class="mdescRight">The existing blocks as a list of (file_position, size) pairs.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#aebcb4ccea430a954d95502399306e771">More...</a><br /></td></tr>
<tr class="separator:aebcb4ccea430a954d95502399306e771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac54ea133274f421d2159a5b4a30641c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#aac54ea133274f421d2159a5b4a30641c">block_size</a> (<a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> fpos) const</td></tr>
<tr class="memdesc:aac54ea133274f421d2159a5b4a30641c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of the block at a specific file position.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#aac54ea133274f421d2159a5b4a30641c">More...</a><br /></td></tr>
<tr class="separator:aac54ea133274f421d2159a5b4a30641c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e95ff6a7f05cdcb7d534bb4eabcb1a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a24e95ff6a7f05cdcb7d534bb4eabcb1a">size_of</a> () const noexcept</td></tr>
<tr class="memdesc:a24e95ff6a7f05cdcb7d534bb4eabcb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a24e95ff6a7f05cdcb7d534bb4eabcb1a" title="size_of() gives best guess of total memory usage.">size_of()</a> gives best guess of total memory usage.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a24e95ff6a7f05cdcb7d534bb4eabcb1a">More...</a><br /></td></tr>
<tr class="separator:a24e95ff6a7f05cdcb7d534bb4eabcb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480da981319d2a3a7d2ad46ce6055380"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a480da981319d2a3a7d2ad46ce6055380">num_bytes</a> () const noexcept</td></tr>
<tr class="memdesc:a480da981319d2a3a7d2ad46ce6055380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives exact number of data bytes held.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a480da981319d2a3a7d2ad46ce6055380">More...</a><br /></td></tr>
<tr class="separator:a480da981319d2a3a7d2ad46ce6055380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4031e0bf4b691bc702086bf2403a0777"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a4031e0bf4b691bc702086bf2403a0777">num_blocks</a> () const noexcept</td></tr>
<tr class="memdesc:a4031e0bf4b691bc702086bf2403a0777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of blocks used.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a4031e0bf4b691bc702086bf2403a0777">More...</a><br /></td></tr>
<tr class="separator:a4031e0bf4b691bc702086bf2403a0777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87964eeb0075d83fb9e97bdf5e511df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad87964eeb0075d83fb9e97bdf5e511df">last_file_position</a> () const noexcept</td></tr>
<tr class="memdesc:ad87964eeb0075d83fb9e97bdf5e511df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position of the last byte.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad87964eeb0075d83fb9e97bdf5e511df">More...</a><br /></td></tr>
<tr class="separator:ad87964eeb0075d83fb9e97bdf5e511df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f5a5eedbf7de4923df56c4059882ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ab3f5a5eedbf7de4923df56c4059882ba">file_mod_time_matches</a> (const double &amp;<a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a4466ba8fbac9b8112aa525efe913cb2d">file_mod_time</a>) const noexcept</td></tr>
<tr class="separator:ab3f5a5eedbf7de4923df56c4059882ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dba399c3b8d0b5c56c2053455132d7"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a47dba399c3b8d0b5c56c2053455132d7">id</a> () const noexcept</td></tr>
<tr class="memdesc:a47dba399c3b8d0b5c56c2053455132d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ID of the file.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a47dba399c3b8d0b5c56c2053455132d7">More...</a><br /></td></tr>
<tr class="separator:a47dba399c3b8d0b5c56c2053455132d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4466ba8fbac9b8112aa525efe913cb2d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a4466ba8fbac9b8112aa525efe913cb2d">file_mod_time</a> () const noexcept</td></tr>
<tr class="memdesc:a4466ba8fbac9b8112aa525efe913cb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The file modification time as a double representing UNIX seconds.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a4466ba8fbac9b8112aa525efe913cb2d">More...</a><br /></td></tr>
<tr class="separator:a4466ba8fbac9b8112aa525efe913cb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7d0ea05d7a27e94ffbb3a74cb8d150"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_s_v_f_s.html#a1eab55d2643d9e51c4f4595b78afe9af">tSparseVirtualFileConfig</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5f7d0ea05d7a27e94ffbb3a74cb8d150">config</a> () const noexcept</td></tr>
<tr class="memdesc:a5f7d0ea05d7a27e94ffbb3a74cb8d150"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5f7d0ea05d7a27e94ffbb3a74cb8d150">More...</a><br /></td></tr>
<tr class="separator:a5f7d0ea05d7a27e94ffbb3a74cb8d150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2678dc53b5e2ab15f3a82a4a699622a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad2678dc53b5e2ab15f3a82a4a699622a">count_write</a> () const noexcept</td></tr>
<tr class="memdesc:ad2678dc53b5e2ab15f3a82a4a699622a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5ae9a0a31892a3b41581ab888dd1323c" title="Write the data a the given file position.">write()</a></code> operations.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad2678dc53b5e2ab15f3a82a4a699622a">More...</a><br /></td></tr>
<tr class="separator:ad2678dc53b5e2ab15f3a82a4a699622a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e68937e422d8935e08fa8498e2d449"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#aa2e68937e422d8935e08fa8498e2d449">count_read</a> () const noexcept</td></tr>
<tr class="memdesc:aa2e68937e422d8935e08fa8498e2d449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad92b513994c68322312358db4197ac94" title="Read data and write to the buffer provided by the caller. This is non-const as it updates the non-con...">read()</a></code> operations.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#aa2e68937e422d8935e08fa8498e2d449">More...</a><br /></td></tr>
<tr class="separator:aa2e68937e422d8935e08fa8498e2d449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa9a8b3b6d90459a5c6cf2eaba772e7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#aafa9a8b3b6d90459a5c6cf2eaba772e7">bytes_write</a> () const noexcept</td></tr>
<tr class="memdesc:aafa9a8b3b6d90459a5c6cf2eaba772e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of total bytes written with <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5ae9a0a31892a3b41581ab888dd1323c" title="Write the data a the given file position.">write()</a></code> operations.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#aafa9a8b3b6d90459a5c6cf2eaba772e7">More...</a><br /></td></tr>
<tr class="separator:aafa9a8b3b6d90459a5c6cf2eaba772e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009ac567b03d6496a26d3f64de9ff66d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a009ac567b03d6496a26d3f64de9ff66d">bytes_read</a> () const noexcept</td></tr>
<tr class="memdesc:a009ac567b03d6496a26d3f64de9ff66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of total bytes read with <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad92b513994c68322312358db4197ac94" title="Read data and write to the buffer provided by the caller. This is non-const as it updates the non-con...">read()</a></code> operations.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a009ac567b03d6496a26d3f64de9ff66d">More...</a><br /></td></tr>
<tr class="separator:a009ac567b03d6496a26d3f64de9ff66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98702dcd0f564aeda8ccb7ee89769e62"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a98702dcd0f564aeda8ccb7ee89769e62">blocks_erased</a> () const noexcept</td></tr>
<tr class="memdesc:a98702dcd0f564aeda8ccb7ee89769e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the The total count of blocks that have been erased either directly or by punting.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a98702dcd0f564aeda8ccb7ee89769e62">More...</a><br /></td></tr>
<tr class="separator:a98702dcd0f564aeda8ccb7ee89769e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fb876940069e8b38725a46a2d65639"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a44fb876940069e8b38725a46a2d65639">bytes_erased</a> () const noexcept</td></tr>
<tr class="memdesc:a44fb876940069e8b38725a46a2d65639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the The total count of bytes that have been erased either directly or by punting.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a44fb876940069e8b38725a46a2d65639">More...</a><br /></td></tr>
<tr class="separator:a44fb876940069e8b38725a46a2d65639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3330aa5412a65040135012a9866b2a60"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a3330aa5412a65040135012a9866b2a60">blocks_punted</a> () const noexcept</td></tr>
<tr class="memdesc:a3330aa5412a65040135012a9866b2a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the The total count of blocks that have been erased by punting.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a3330aa5412a65040135012a9866b2a60">More...</a><br /></td></tr>
<tr class="separator:a3330aa5412a65040135012a9866b2a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7720aa1fedeebcc3847b262aa151df60"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a7720aa1fedeebcc3847b262aa151df60">bytes_punted</a> () const noexcept</td></tr>
<tr class="memdesc:a7720aa1fedeebcc3847b262aa151df60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the The total count of bytes that have been erased by punting.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a7720aa1fedeebcc3847b262aa151df60">More...</a><br /></td></tr>
<tr class="separator:a7720aa1fedeebcc3847b262aa151df60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dad8e7b97912c6c5b54a5230fc306ac"><td class="memItemLeft" align="right" valign="top">std::chrono::time_point&lt; std::chrono::system_clock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a4dad8e7b97912c6c5b54a5230fc306ac">time_write</a> () const noexcept</td></tr>
<tr class="separator:a4dad8e7b97912c6c5b54a5230fc306ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bf020a4ff40d4d232bf8ff695c84a7"><td class="memItemLeft" align="right" valign="top">std::chrono::time_point&lt; std::chrono::system_clock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a91bf020a4ff40d4d232bf8ff695c84a7">time_read</a> () const noexcept</td></tr>
<tr class="separator:a91bf020a4ff40d4d232bf8ff695c84a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570900eea55726be32f9a0df9d8849e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_v_f_s.html#ae056c270d122162bdbdc2bce297e693c">t_block_touch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a570900eea55726be32f9a0df9d8849e2">block_touch</a> () const noexcept</td></tr>
<tr class="memdesc:a570900eea55726be32f9a0df9d8849e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the latest value of the monotonically increasing block_touch value.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a570900eea55726be32f9a0df9d8849e2">More...</a><br /></td></tr>
<tr class="separator:a570900eea55726be32f9a0df9d8849e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3768e98b92d53dc55298e13d4d7046cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_v_f_s.html#a769b7b98acc703bfb660d56dd964fdce">t_block_touches</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a3768e98b92d53dc55298e13d4d7046cb">block_touches</a> () const noexcept</td></tr>
<tr class="memdesc:a3768e98b92d53dc55298e13d4d7046cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>std::map</code> of latest touch value key and file position value.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a3768e98b92d53dc55298e13d4d7046cb">More...</a><br /></td></tr>
<tr class="separator:a3768e98b92d53dc55298e13d4d7046cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2f1d0350fd4f69387c6363fb83b311"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a2b2f1d0350fd4f69387c6363fb83b311">lru_punt</a> (size_t cache_size_upper_bound)</td></tr>
<tr class="separator:a2b2f1d0350fd4f69387c6363fb83b311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c878a366d003f7e9c3152704d9a6023"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a2c878a366d003f7e9c3152704d9a6023">SparseVirtualFile</a> (const <a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html">SparseVirtualFile</a> &amp;rhs)=delete</td></tr>
<tr class="memdesc:a2c878a366d003f7e9c3152704d9a6023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate copying.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a2c878a366d003f7e9c3152704d9a6023">More...</a><br /></td></tr>
<tr class="separator:a2c878a366d003f7e9c3152704d9a6023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3010a7cbd7f78ee8fd49f4fe0fc471"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html">SparseVirtualFile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a7b3010a7cbd7f78ee8fd49f4fe0fc471">operator=</a> (const <a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html">SparseVirtualFile</a> &amp;rhs)=delete</td></tr>
<tr class="memdesc:a7b3010a7cbd7f78ee8fd49f4fe0fc471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate copying.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a7b3010a7cbd7f78ee8fd49f4fe0fc471">More...</a><br /></td></tr>
<tr class="separator:a7b3010a7cbd7f78ee8fd49f4fe0fc471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79ebe748522e8b991662a99a5423d87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ae79ebe748522e8b991662a99a5423d87">SparseVirtualFile</a> (<a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html">SparseVirtualFile</a> &amp;&amp;other)=delete</td></tr>
<tr class="memdesc:ae79ebe748522e8b991662a99a5423d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prohibit moving, the mutex has no move constructor.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#ae79ebe748522e8b991662a99a5423d87">More...</a><br /></td></tr>
<tr class="separator:ae79ebe748522e8b991662a99a5423d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f8d6206706a1acf3a83466f7482fef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html">SparseVirtualFile</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a08f8d6206706a1acf3a83466f7482fef">operator=</a> (<a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html">SparseVirtualFile</a> &amp;&amp;rhs)=delete</td></tr>
<tr class="separator:a08f8d6206706a1acf3a83466f7482fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaaa85d325aaffc28d7f4d1d178924de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#aeaaa85d325aaffc28d7f4d1d178924de">~SparseVirtualFile</a> ()</td></tr>
<tr class="memdesc:aeaaa85d325aaffc28d7f4d1d178924de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruction just clears the internal map.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#aeaaa85d325aaffc28d7f4d1d178924de">More...</a><br /></td></tr>
<tr class="separator:aeaaa85d325aaffc28d7f4d1d178924de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a0b3e9296b2987975edf1b2e8f60a15c6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0b3e9296b2987975edf1b2e8f60a15c6">ERROR_CONDITION</a> { <br />
&#160;&#160;<a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0b3e9296b2987975edf1b2e8f60a15c6a7e1acdae7fd78ba7cc683c1fae67b33b">ERROR_NONE</a> = 0
, <a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0b3e9296b2987975edf1b2e8f60a15c6abecd79e81414f084c7c0c8975ea91c50">ERROR_EMPTY_BLOCK</a>
, <a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0b3e9296b2987975edf1b2e8f60a15c6a7bb27459a31c4d0ccdd3e75fa6dae337">ERROR_ADJACENT_BLOCKS</a>
, <a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0b3e9296b2987975edf1b2e8f60a15c6a4f27c404a50b57bae33759cc31d0981b">ERROR_BLOCKS_OVERLAP</a>
, <br />
&#160;&#160;<a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0b3e9296b2987975edf1b2e8f60a15c6a9e4280990c4ef4f085a59526a9f9b219">ERROR_BYTE_COUNT_MISMATCH</a>
, <a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0b3e9296b2987975edf1b2e8f60a15c6ab70a9d6945eea2a163fecf7296ae30f5">ERROR_DUPLICATE_BLOCK</a>
, <a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0b3e9296b2987975edf1b2e8f60a15c6ad0e8dc4245409c495cb7c12676909e52">ERROR_DUPLICATE_BLOCK_TOUCH</a>
<br />
 }</td></tr>
<tr class="memdesc:a0b3e9296b2987975edf1b2e8f60a15c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check result of internal integrity.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0b3e9296b2987975edf1b2e8f60a15c6">More...</a><br /></td></tr>
<tr class="separator:a0b3e9296b2987975edf1b2e8f60a15c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa892b09c0fc5ffcfebcadf44b7b1035"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>, <a class="el" href="struct_s_v_f_s_1_1_sparse_virtual_file_1_1t__val.html">t_val</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#afa892b09c0fc5ffcfebcadf44b7b1035">t_map</a></td></tr>
<tr class="memdesc:afa892b09c0fc5ffcfebcadf44b7b1035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the map of file blocks &lt;file_position, data&gt;.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#afa892b09c0fc5ffcfebcadf44b7b1035">More...</a><br /></td></tr>
<tr class="separator:afa892b09c0fc5ffcfebcadf44b7b1035"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a439cb211ebbf8b187b1da0e20747ad91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a439cb211ebbf8b187b1da0e20747ad91">_throw_diff</a> (<a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> fpos, const char *data, t_map::const_iterator iter, size_t index_iter) const</td></tr>
<tr class="memdesc:a439cb211ebbf8b187b1da0e20747ad91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws a ExceptionSparseVirtualFileDiff with an explanation of the data difference.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a439cb211ebbf8b187b1da0e20747ad91">More...</a><br /></td></tr>
<tr class="separator:a439cb211ebbf8b187b1da0e20747ad91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5003648da5b9d0ff40baf6c4d4a747"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#abf5003648da5b9d0ff40baf6c4d4a747">_write_new_block</a> (<a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> fpos, const char *data, size_t len, t_map::const_iterator hint)</td></tr>
<tr class="memdesc:abf5003648da5b9d0ff40baf6c4d4a747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a brand new block into either an empty SVF or beyond the current blocks.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#abf5003648da5b9d0ff40baf6c4d4a747">More...</a><br /></td></tr>
<tr class="separator:abf5003648da5b9d0ff40baf6c4d4a747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a09a84eddb026dae7240856da5a1d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a70a09a84eddb026dae7240856da5a1d0">_write_new_append_old</a> (<a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> fpos, const char *data, size_t len, t_map::iterator iter)</td></tr>
<tr class="memdesc:a70a09a84eddb026dae7240856da5a1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a new block and append existing blocks to it.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a70a09a84eddb026dae7240856da5a1d0">More...</a><br /></td></tr>
<tr class="separator:a70a09a84eddb026dae7240856da5a1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed2e0fcf5d74e60a9a5e2fe50f1a6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a2ed2e0fcf5d74e60a9a5e2fe50f1a6f9">_write_append_new_to_old</a> (<a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> fpos, const char *new_data, size_t new_data_len, t_map::iterator base_block_iter)</td></tr>
<tr class="memdesc:a2ed2e0fcf5d74e60a9a5e2fe50f1a6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">From file position, write the new_data to the block identified by base_block_iter. This may involve coalescing existing blocks that follow base_block_iter.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a2ed2e0fcf5d74e60a9a5e2fe50f1a6f9">More...</a><br /></td></tr>
<tr class="separator:a2ed2e0fcf5d74e60a9a5e2fe50f1a6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8b96eec1f97766176ea6fc5802c689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0d8b96eec1f97766176ea6fc5802c689">_file_position_immediatly_after_end</a> () const noexcept</td></tr>
<tr class="memdesc:a0d8b96eec1f97766176ea6fc5802c689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the file position immediately after the last block.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0d8b96eec1f97766176ea6fc5802c689">More...</a><br /></td></tr>
<tr class="separator:a0d8b96eec1f97766176ea6fc5802c689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6867307e2fd9c2800c46788cf0987b2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a6867307e2fd9c2800c46788cf0987b2e">_file_position_immediatly_after_block</a> (t_map::const_iterator iter) const noexcept</td></tr>
<tr class="memdesc:a6867307e2fd9c2800c46788cf0987b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the file position immediately after the particular block.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a6867307e2fd9c2800c46788cf0987b2e">More...</a><br /></td></tr>
<tr class="separator:a6867307e2fd9c2800c46788cf0987b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada52405d62ccd1b9727f6f492a156331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ada52405d62ccd1b9727f6f492a156331">_need_no_lock</a> (<a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> fpos, size_t len, size_t greedy_length=0) const noexcept</td></tr>
<tr class="separator:ada52405d62ccd1b9727f6f492a156331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00d0f8651d9e3e15187af76b5e2c946"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ab00d0f8651d9e3e15187af76b5e2c946">_erase_no_lock</a> (<a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> fpos)</td></tr>
<tr class="memdesc:ab00d0f8651d9e3e15187af76b5e2c946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a particular block.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#ab00d0f8651d9e3e15187af76b5e2c946">More...</a><br /></td></tr>
<tr class="separator:ab00d0f8651d9e3e15187af76b5e2c946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b033eba2d20c1b009fcb1962587ca4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_v_f_s.html#a769b7b98acc703bfb660d56dd964fdce">t_block_touches</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a86b033eba2d20c1b009fcb1962587ca4">_block_touches_no_lock</a> () const noexcept</td></tr>
<tr class="memdesc:a86b033eba2d20c1b009fcb1962587ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>std::map</code> of latest touch value key and file position value.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a86b033eba2d20c1b009fcb1962587ca4">More...</a><br /></td></tr>
<tr class="separator:a86b033eba2d20c1b009fcb1962587ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bdd9522da5fb32237738fb3217ac7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0b3e9296b2987975edf1b2e8f60a15c6">ERROR_CONDITION</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ac3bdd9522da5fb32237738fb3217ac7c">integrity</a> () const noexcept</td></tr>
<tr class="memdesc:ac3bdd9522da5fb32237738fb3217ac7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal integrity check.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#ac3bdd9522da5fb32237738fb3217ac7c">More...</a><br /></td></tr>
<tr class="separator:ac3bdd9522da5fb32237738fb3217ac7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a8b0c3d71e16e0ee9ca62acff1ef83bd0"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a8b0c3d71e16e0ee9ca62acff1ef83bd0">_amount_to_read</a> (<a class="el" href="namespace_s_v_f_s.html#a9d4fc55cfa691e58121c7a99bba2a29c">t_seek_read</a> iter, size_t greedy_length) noexcept</td></tr>
<tr class="memdesc:a8b0c3d71e16e0ee9ca62acff1ef83bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal length to read given a greedy length.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a8b0c3d71e16e0ee9ca62acff1ef83bd0">More...</a><br /></td></tr>
<tr class="separator:a8b0c3d71e16e0ee9ca62acff1ef83bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fab1ec7892776a85cf79f3102fe85ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a1fab1ec7892776a85cf79f3102fe85ce">_minimise_seek_reads</a> (const <a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a> &amp;seek_reads, size_t greedy_length) noexcept</td></tr>
<tr class="memdesc:a1fab1ec7892776a85cf79f3102fe85ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">May reduce the list of file position/lengths by coalescing them if possible up to a limit <code>greedy_length</code>.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a1fab1ec7892776a85cf79f3102fe85ce">More...</a><br /></td></tr>
<tr class="separator:a1fab1ec7892776a85cf79f3102fe85ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae77810bd9ca991f4b462bb5d671026f7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ae77810bd9ca991f4b462bb5d671026f7">m_id</a></td></tr>
<tr class="memdesc:ae77810bd9ca991f4b462bb5d671026f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SVF ID.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#ae77810bd9ca991f4b462bb5d671026f7">More...</a><br /></td></tr>
<tr class="separator:ae77810bd9ca991f4b462bb5d671026f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5930e519f16ef64d6023381c2b010b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ade5930e519f16ef64d6023381c2b010b">m_file_mod_time</a></td></tr>
<tr class="memdesc:ade5930e519f16ef64d6023381c2b010b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The original file modification date as UNIX time. This is used for consistency checking.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#ade5930e519f16ef64d6023381c2b010b">More...</a><br /></td></tr>
<tr class="separator:ade5930e519f16ef64d6023381c2b010b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356bad14f44aaca0b0e0a334295a3d87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_v_f_s.html#a1eab55d2643d9e51c4f4595b78afe9af">tSparseVirtualFileConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a356bad14f44aaca0b0e0a334295a3d87">m_config</a></td></tr>
<tr class="memdesc:a356bad14f44aaca0b0e0a334295a3d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SVF configuration.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a356bad14f44aaca0b0e0a334295a3d87">More...</a><br /></td></tr>
<tr class="separator:a356bad14f44aaca0b0e0a334295a3d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254a9afdc57eed4b0c44ecaac4fa34cc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a254a9afdc57eed4b0c44ecaac4fa34cc">m_bytes_total</a> = 0</td></tr>
<tr class="memdesc:a254a9afdc57eed4b0c44ecaac4fa34cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of bytes in this SVF.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a254a9afdc57eed4b0c44ecaac4fa34cc">More...</a><br /></td></tr>
<tr class="separator:a254a9afdc57eed4b0c44ecaac4fa34cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5500469ea7728c0332e7d7592e90f6f9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5500469ea7728c0332e7d7592e90f6f9">m_count_write</a> = 0</td></tr>
<tr class="memdesc:a5500469ea7728c0332e7d7592e90f6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access statistics: count of write operations.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5500469ea7728c0332e7d7592e90f6f9">More...</a><br /></td></tr>
<tr class="separator:a5500469ea7728c0332e7d7592e90f6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda4430a1d0ba01d27c84d2ad5af2860"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#adda4430a1d0ba01d27c84d2ad5af2860">m_count_read</a> = 0</td></tr>
<tr class="memdesc:adda4430a1d0ba01d27c84d2ad5af2860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access statistics: count of read operations.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#adda4430a1d0ba01d27c84d2ad5af2860">More...</a><br /></td></tr>
<tr class="separator:adda4430a1d0ba01d27c84d2ad5af2860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42406904001643468eb4db07771fbcf1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a42406904001643468eb4db07771fbcf1">m_bytes_write</a> = 0</td></tr>
<tr class="separator:a42406904001643468eb4db07771fbcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2736ef8a5cd7fb7d3a7e38015e3d7104"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a2736ef8a5cd7fb7d3a7e38015e3d7104">m_bytes_read</a> = 0</td></tr>
<tr class="separator:a2736ef8a5cd7fb7d3a7e38015e3d7104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2487ccdb7ad98eac1ba31600d2c618d4"><td class="memItemLeft" align="right" valign="top">std::chrono::time_point&lt; std::chrono::system_clock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a2487ccdb7ad98eac1ba31600d2c618d4">m_time_write</a></td></tr>
<tr class="memdesc:a2487ccdb7ad98eac1ba31600d2c618d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last access real-time timestamp for a write.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a2487ccdb7ad98eac1ba31600d2c618d4">More...</a><br /></td></tr>
<tr class="separator:a2487ccdb7ad98eac1ba31600d2c618d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599beee3f87fd17a02cbca30d4f11152"><td class="memItemLeft" align="right" valign="top">std::chrono::time_point&lt; std::chrono::system_clock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a599beee3f87fd17a02cbca30d4f11152">m_time_read</a></td></tr>
<tr class="memdesc:a599beee3f87fd17a02cbca30d4f11152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last access real-time timestamp for a read.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a599beee3f87fd17a02cbca30d4f11152">More...</a><br /></td></tr>
<tr class="separator:a599beee3f87fd17a02cbca30d4f11152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad723c792fb2ff20bca02461f0c15d1b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#afa892b09c0fc5ffcfebcadf44b7b1035">t_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad723c792fb2ff20bca02461f0c15d1b7">m_svf</a></td></tr>
<tr class="memdesc:ad723c792fb2ff20bca02461f0c15d1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual SVF.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad723c792fb2ff20bca02461f0c15d1b7">More...</a><br /></td></tr>
<tr class="separator:ad723c792fb2ff20bca02461f0c15d1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53a552eb5407bd0bdd840e993d10c2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_v_f_s.html#ae056c270d122162bdbdc2bce297e693c">t_block_touch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#af53a552eb5407bd0bdd840e993d10c2d">m_block_touch</a></td></tr>
<tr class="memdesc:af53a552eb5407bd0bdd840e993d10c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A monotonically increasing integer that indicates the age of a block, smaller is older.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#af53a552eb5407bd0bdd840e993d10c2d">More...</a><br /></td></tr>
<tr class="separator:af53a552eb5407bd0bdd840e993d10c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ca5dd3feac91a4b891ebc13fe8ba6e"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad4ca5dd3feac91a4b891ebc13fe8ba6e">m_mutex</a></td></tr>
<tr class="memdesc:ad4ca5dd3feac91a4b891ebc13fe8ba6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread mutex. This adds about 5-10% execution time compared with a single threaded version.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad4ca5dd3feac91a4b891ebc13fe8ba6e">More...</a><br /></td></tr>
<tr class="separator:ad4ca5dd3feac91a4b891ebc13fe8ba6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c71f2fd2d1aba0de7f4a38d10ae044"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a50c71f2fd2d1aba0de7f4a38d10ae044">m_blocks_erased</a></td></tr>
<tr class="memdesc:a50c71f2fd2d1aba0de7f4a38d10ae044"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total count of blocks that have been erased either directly or by punting.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a50c71f2fd2d1aba0de7f4a38d10ae044">More...</a><br /></td></tr>
<tr class="separator:a50c71f2fd2d1aba0de7f4a38d10ae044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49040796a4b59d7d2ac4285ec71ae3de"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a49040796a4b59d7d2ac4285ec71ae3de">m_bytes_erased</a></td></tr>
<tr class="memdesc:a49040796a4b59d7d2ac4285ec71ae3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total count of bytes that have been erased either directly or by punting.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a49040796a4b59d7d2ac4285ec71ae3de">More...</a><br /></td></tr>
<tr class="separator:a49040796a4b59d7d2ac4285ec71ae3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a124b18adfd859010434f7966780d9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a29a124b18adfd859010434f7966780d9">m_blocks_punted</a></td></tr>
<tr class="memdesc:a29a124b18adfd859010434f7966780d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count of blocks that have been erased by punting.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a29a124b18adfd859010434f7966780d9">More...</a><br /></td></tr>
<tr class="separator:a29a124b18adfd859010434f7966780d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4a550ca8131b0f1b7a814ae6d367d0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a1b4a550ca8131b0f1b7a814ae6d367d0">m_bytes_punted</a></td></tr>
<tr class="memdesc:a1b4a550ca8131b0f1b7a814ae6d367d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count of bytes that have been erased by punting.  <a href="class_s_v_f_s_1_1_sparse_virtual_file.html#a1b4a550ca8131b0f1b7a814ae6d367d0">More...</a><br /></td></tr>
<tr class="separator:a1b4a550ca8131b0f1b7a814ae6d367d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of a <em>Sparse Virtual File</em>. </p>
<p>A <em>Sparse Virtual File</em>, a specialised in-memory cache where a particular file might not be available but <em>parts of it can be obtained</em> without reading the whole file. A Sparse Virtual File (SVF) is represented internally as a map of blocks of data with the key being their file offsets. Any write to an SVF will coalesce those blocks where possible. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00288">288</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afa892b09c0fc5ffcfebcadf44b7b1035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa892b09c0fc5ffcfebcadf44b7b1035">&#9670;&nbsp;</a></span>t_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>, <a class="el" href="struct_s_v_f_s_1_1_sparse_virtual_file_1_1t__val.html">t_val</a>&gt; <a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#afa892b09c0fc5ffcfebcadf44b7b1035">SVFS::SparseVirtualFile::t_map</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Typedef for the map of file blocks &lt;file_position, data&gt;. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00467">467</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a0b3e9296b2987975edf1b2e8f60a15c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3e9296b2987975edf1b2e8f60a15c6">&#9670;&nbsp;</a></span>ERROR_CONDITION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0b3e9296b2987975edf1b2e8f60a15c6">SVFS::SparseVirtualFile::ERROR_CONDITION</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check result of internal integrity. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0b3e9296b2987975edf1b2e8f60a15c6a7e1acdae7fd78ba7cc683c1fae67b33b"></a>ERROR_NONE&#160;</td><td class="fielddoc"><p>No error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0b3e9296b2987975edf1b2e8f60a15c6abecd79e81414f084c7c0c8975ea91c50"></a>ERROR_EMPTY_BLOCK&#160;</td><td class="fielddoc"><p>A block is empty. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0b3e9296b2987975edf1b2e8f60a15c6a7bb27459a31c4d0ccdd3e75fa6dae337"></a>ERROR_ADJACENT_BLOCKS&#160;</td><td class="fielddoc"><p>Blocks are adjacent and have not been coalesced. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0b3e9296b2987975edf1b2e8f60a15c6a4f27c404a50b57bae33759cc31d0981b"></a>ERROR_BLOCKS_OVERLAP&#160;</td><td class="fielddoc"><p>Blocks overlap. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0b3e9296b2987975edf1b2e8f60a15c6a9e4280990c4ef4f085a59526a9f9b219"></a>ERROR_BYTE_COUNT_MISMATCH&#160;</td><td class="fielddoc"><p>Missmatch in byte count where the count of the bytes in all the blocks does not match <code>m_bytes_total</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0b3e9296b2987975edf1b2e8f60a15c6ab70a9d6945eea2a163fecf7296ae30f5"></a>ERROR_DUPLICATE_BLOCK&#160;</td><td class="fielddoc"><p>Duplicate blocks of the same length and at the same file positions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0b3e9296b2987975edf1b2e8f60a15c6ad0e8dc4245409c495cb7c12676909e52"></a>ERROR_DUPLICATE_BLOCK_TOUCH&#160;</td><td class="fielddoc"><p>Two or more blocks have the same block touch value. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00510">510</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5238b80ed9e7ed3421e74b3d492dba94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5238b80ed9e7ed3421e74b3d492dba94">&#9670;&nbsp;</a></span>SparseVirtualFile() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SVFS::SparseVirtualFile::SparseVirtualFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mod_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_s_v_f_s.html#a1eab55d2643d9e51c4f4595b78afe9af">tSparseVirtualFileConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="namespace_s_v_f_s.html#a1eab55d2643d9e51c4f4595b78afe9af">tSparseVirtualFileConfig</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a Sparse Virtual File. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The identifier for this file. </td></tr>
    <tr><td class="paramname">mod_time</td><td>The modification time of the remote file in UNIX seconds, this is used for integrity checking. </td></tr>
    <tr><td class="paramname">config</td><td>See <code><a class="el" href="struct_s_v_f_s_1_1_sparse_virtual_file_config.html" title="Configuration for the Sparse Virtual File.">SVFS::SparseVirtualFileConfig</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00297">297</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a2c878a366d003f7e9c3152704d9a6023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c878a366d003f7e9c3152704d9a6023">&#9670;&nbsp;</a></span>SparseVirtualFile() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SVFS::SparseVirtualFile::SparseVirtualFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html">SparseVirtualFile</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminate copying. </p>

</div>
</div>
<a id="ae79ebe748522e8b991662a99a5423d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79ebe748522e8b991662a99a5423d87">&#9670;&nbsp;</a></span>SparseVirtualFile() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SVFS::SparseVirtualFile::SparseVirtualFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html">SparseVirtualFile</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prohibit moving, the mutex has no move constructor. </p>

</div>
</div>
<a id="aeaaa85d325aaffc28d7f4d1d178924de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaaa85d325aaffc28d7f4d1d178924de">&#9670;&nbsp;</a></span>~SparseVirtualFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SVFS::SparseVirtualFile::~SparseVirtualFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destruction just clears the internal map. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00435">435</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8b0c3d71e16e0ee9ca62acff1ef83bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0c3d71e16e0ee9ca62acff1ef83bd0">&#9670;&nbsp;</a></span>_amount_to_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::_amount_to_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#a9d4fc55cfa691e58121c7a99bba2a29c">t_seek_read</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>greedy_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximal length to read given a greedy length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The current block. </td></tr>
    <tr><td class="paramname">greedy_length</td><td>The greed length read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximal read value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00734">734</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a86b033eba2d20c1b009fcb1962587ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b033eba2d20c1b009fcb1962587ca4">&#9670;&nbsp;</a></span>_block_touches_no_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_v_f_s.html#a769b7b98acc703bfb660d56dd964fdce">t_block_touches</a> SVFS::SparseVirtualFile::_block_touches_no_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code>std::map</code> of latest touch value key and file position value. </p>
<p>Callers can use this to make informed decisions about punting older blocks.</p>
<dl class="section return"><dt>Returns</dt><dd>A map std::map&lt;t_block_touch, t_fpos&gt;. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00987">987</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="ab00d0f8651d9e3e15187af76b5e2c946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00d0f8651d9e3e15187af76b5e2c946">&#9670;&nbsp;</a></span>_erase_no_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::_erase_no_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td>
          <td class="paramname"><em>fpos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a particular block. </p>
<p>This will raise an ExceptionSparseVirtualFileErase if the file position is not exactly at the start of a block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpos</td><td>File position of the start of the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the block that was removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00879">879</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a6867307e2fd9c2800c46788cf0987b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6867307e2fd9c2800c46788cf0987b2e">&#9670;&nbsp;</a></span>_file_position_immediatly_after_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> SVFS::SparseVirtualFile::_file_position_immediatly_after_block </td>
          <td>(</td>
          <td class="paramtype">t_map::const_iterator&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the file position immediately after the particular block. </p>
<p>Example file position 4, block length 2 this returns 6.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator to the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last known file position. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l01070">1070</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a0d8b96eec1f97766176ea6fc5802c689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8b96eec1f97766176ea6fc5802c689">&#9670;&nbsp;</a></span>_file_position_immediatly_after_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> SVFS::SparseVirtualFile::_file_position_immediatly_after_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the file position immediately after the last block. </p>
<p>Of course this is not the EOF position as we may not have been offered that yet. This does not have use a lock.</p>
<dl class="section return"><dt>Returns</dt><dd>The last know file position. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l01051">1051</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a1fab1ec7892776a85cf79f3102fe85ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fab1ec7892776a85cf79f3102fe85ce">&#9670;&nbsp;</a></span>_minimise_seek_reads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a> SVFS::SparseVirtualFile::_minimise_seek_reads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a> &amp;&#160;</td>
          <td class="paramname"><em>seek_reads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>greedy_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>May reduce the list of file position/lengths by coalescing them if possible up to a limit <code>greedy_length</code>. </p>
<p>NOTE: greedy_length of 0 is allowed, in that case this will coalesce overlapping blocks (if any).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seek_reads</td><td>Vector of minimal seek/reads. </td></tr>
    <tr><td class="paramname">greedy_length</td><td>Maximal length that allows coalescing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New vector of maximal seek/reads. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00748">748</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="ada52405d62ccd1b9727f6f492a156331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada52405d62ccd1b9727f6f492a156331">&#9670;&nbsp;</a></span>_need_no_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a> SVFS::SparseVirtualFile::_need_no_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td>
          <td class="paramname"><em>fpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>greedy_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00590">590</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a439cb211ebbf8b187b1da0e20747ad91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439cb211ebbf8b187b1da0e20747ad91">&#9670;&nbsp;</a></span>_throw_diff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVFS::SparseVirtualFile::_throw_diff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td>
          <td class="paramname"><em>fpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_map::const_iterator&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws a ExceptionSparseVirtualFileDiff with an explanation of the data difference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpos</td><td>File position. </td></tr>
    <tr><td class="paramname">data</td><td>The data. </td></tr>
    <tr><td class="paramname">iter</td><td>The iterator to the block which has different data. </td></tr>
    <tr><td class="paramname">index_iter</td><td>The index into that block where the first data difference starts. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00085">85</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a2ed2e0fcf5d74e60a9a5e2fe50f1a6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed2e0fcf5d74e60a9a5e2fe50f1a6f9">&#9670;&nbsp;</a></span>_write_append_new_to_old()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVFS::SparseVirtualFile::_write_append_new_to_old </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td>
          <td class="paramname"><em>fpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_map::iterator&#160;</td>
          <td class="paramname"><em>base_block_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>From file position, write the new_data to the block identified by base_block_iter. This may involve coalescing existing blocks that follow base_block_iter. </p>
<p>We are in these kind of situations:</p>
<p>Notation:</p>
<ol type="1">
<li>Means original blocks.</li>
<li>Is new data to be added</li>
<li>Is the result.</li>
</ol>
<p>And the characters mean:</p>
<ul>
<li><code>%</code> Is the new file position to write to, argument <code>fpos</code> </li>
<li><code>^</code> Is the iterator file position, argument <code>base_block_iter.first</code> </li>
<li><code>=</code> Means original data, argument <code>base_block_iter.second</code> </li>
<li><code>+</code> Means new data, argument <code>new_data</code>.</li>
<li><code>c</code> Means data checked equal (if required).</li>
<li><code>A</code> Means new data appended or added.</li>
</ul>
<div class="fragment"><div class="line">1: ^===========|    |=====|</div>
<div class="line">2: %+++++++++|</div>
<div class="line">3: ^ccccccccc==|    |=====|</div>
<div class="line"> </div>
<div class="line">1: ^===========|    |=====|</div>
<div class="line">2:    %++++++|</div>
<div class="line">3: ^===cccccc==|    |=====|</div>
<div class="line"> </div>
<div class="line">1: ^===========|    |=====|</div>
<div class="line">2:    %+++++++++++|</div>
<div class="line">3: ^===========AAA| |=====|</div>
<div class="line"> </div>
<div class="line">1: ^===========|    |=====|</div>
<div class="line">2:    %++++++++++++++++++|</div>
<div class="line">3: ^===ccccccccAAAAAAcccc=|</div>
<div class="line"> </div>
<div class="line">1: ^===========|    |=====|    |=====|</div>
<div class="line">2:    |++++++++++++++++++++++++++|</div>
<div class="line">3: ^===ccccccccAAAAAAcccccAAAAAAc====|</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpos</td><td>File position of the start of the new new_data. </td></tr>
    <tr><td class="paramname">new_data</td><td>The new_data </td></tr>
    <tr><td class="paramname">new_data_len</td><td>The length of the new data. </td></tr>
    <tr><td class="paramname">base_block_iter</td><td>Block to write to. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00313">313</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a70a09a84eddb026dae7240856da5a1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a09a84eddb026dae7240856da5a1d0">&#9670;&nbsp;</a></span>_write_new_append_old()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVFS::SparseVirtualFile::_write_new_append_old </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td>
          <td class="paramname"><em>fpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_map::iterator&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a new block and append existing blocks to it. </p>
<p>We are in either of these situations.</p>
<p>Notation:</p>
<ol type="1">
<li>Means original blocks.</li>
<li>Is new data to be added</li>
<li>Is the result.</li>
</ol>
<p>And the characters mean:</p>
<ul>
<li><code>%</code> Is the new file position to write to, argument <code>fpos</code> </li>
<li><code>^</code> Is the iterator file position, argument <code>iter.first</code> </li>
<li><code>=</code> Means original data, argument <code>iter.second</code> </li>
<li><code>+</code> Means new data, argument <code>data</code>.</li>
<li><code>c</code> Means data checked equal (if required).</li>
<li><code>A</code> Means new data appended or added.</li>
</ul>
<div class="fragment"><div class="line">1:     ^===========|  |=====|</div>
<div class="line">2: %+++++++++++++++++++++|</div>
<div class="line">3: %AAAAcccccccccccAAAAcc===|</div>
</div><!-- fragment --><p> or: </p><div class="fragment"><div class="line">1:       ^===========|</div>
<div class="line">2: %+++++++++++++++++++++|</div>
<div class="line">3: %AAAAAAcccccccccccAAAA|</div>
</div><!-- fragment --><p> or: </p><div class="fragment"><div class="line">1:      ^===========|</div>
<div class="line">2: %+++++++++++++|</div>
<div class="line">3: %AAAAAcccccccc===|</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpos</td><td>The file position of the start of the new block. </td></tr>
    <tr><td class="paramname">data</td><td>The data to write. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data. </td></tr>
    <tr><td class="paramname">iter</td><td>The iterator of the existing block (<code>'^'</code> above). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00179">179</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="abf5003648da5b9d0ff40baf6c4d4a747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5003648da5b9d0ff40baf6c4d4a747">&#9670;&nbsp;</a></span>_write_new_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVFS::SparseVirtualFile::_write_new_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td>
          <td class="paramname"><em>fpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_map::const_iterator&#160;</td>
          <td class="paramname"><em>hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a brand new block into either an empty SVF or beyond the current blocks. </p>
<p>Will raise an ExceptionSparseVirtualFileWrite if the write fails. This also updates <code>m_bytes_total</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpos</td><td>The file position. </td></tr>
    <tr><td class="paramname">data</td><td>The data. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00113">113</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="aac54ea133274f421d2159a5b4a30641c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac54ea133274f421d2159a5b4a30641c">&#9670;&nbsp;</a></span>block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::block_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td>
          <td class="paramname"><em>fpos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The length of the block at a specific file position. </p>
<p>This will throw a <code>ExceptionSparseVirtualFileRead</code> if the file position is not in the block entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpos</td><td>File position, this must be at the start of a block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The block size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00798">798</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a570900eea55726be32f9a0df9d8849e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570900eea55726be32f9a0df9d8849e2">&#9670;&nbsp;</a></span>block_touch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_v_f_s.html#ae056c270d122162bdbdc2bce297e693c">t_block_touch</a> SVFS::SparseVirtualFile::block_touch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the latest value of the monotonically increasing block_touch value. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00411">411</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a3768e98b92d53dc55298e13d4d7046cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3768e98b92d53dc55298e13d4d7046cb">&#9670;&nbsp;</a></span>block_touches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_v_f_s.html#a769b7b98acc703bfb660d56dd964fdce">t_block_touches</a> SVFS::SparseVirtualFile::block_touches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code>std::map</code> of latest touch value key and file position value. </p>
<p>Callers can use this to make informed decisions about punting older blocks.</p>
<dl class="section return"><dt>Returns</dt><dd>A map std::map&lt;t_block_touch, t_fpos&gt;. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l01005">1005</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="aebcb4ccea430a954d95502399306e771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcb4ccea430a954d95502399306e771">&#9670;&nbsp;</a></span>blocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a> SVFS::SparseVirtualFile::blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The existing blocks as a list of (file_position, size) pairs. </p>
<p>Returns a description of the current blocks as a vector of (file_position, length).</p>
<dl class="section return"><dt>Returns</dt><dd>The currently held blocks. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00777">777</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a98702dcd0f564aeda8ccb7ee89769e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98702dcd0f564aeda8ccb7ee89769e62">&#9670;&nbsp;</a></span>blocks_erased()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::blocks_erased </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the The total count of blocks that have been erased either directly or by punting. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00388">388</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a3330aa5412a65040135012a9866b2a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3330aa5412a65040135012a9866b2a60">&#9670;&nbsp;</a></span>blocks_punted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::blocks_punted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the The total count of blocks that have been erased by punting. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00392">392</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a44fb876940069e8b38725a46a2d65639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fb876940069e8b38725a46a2d65639">&#9670;&nbsp;</a></span>bytes_erased()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::bytes_erased </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the The total count of bytes that have been erased either directly or by punting. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00390">390</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a7720aa1fedeebcc3847b262aa151df60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7720aa1fedeebcc3847b262aa151df60">&#9670;&nbsp;</a></span>bytes_punted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::bytes_punted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the The total count of bytes that have been erased by punting. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00394">394</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a009ac567b03d6496a26d3f64de9ff66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009ac567b03d6496a26d3f64de9ff66d">&#9670;&nbsp;</a></span>bytes_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::bytes_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count of total bytes read with <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad92b513994c68322312358db4197ac94" title="Read data and write to the buffer provided by the caller. This is non-const as it updates the non-con...">read()</a></code> operations. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00385">385</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="aafa9a8b3b6d90459a5c6cf2eaba772e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa9a8b3b6d90459a5c6cf2eaba772e7">&#9670;&nbsp;</a></span>bytes_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::bytes_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count of total bytes written with <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5ae9a0a31892a3b41581ab888dd1323c" title="Write the data a the given file position.">write()</a></code> operations. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00382">382</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a60494f093b0d344c2287564a6e0c053d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60494f093b0d344c2287564a6e0c053d">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVFS::SparseVirtualFile::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the data deletion strategy. </p>
<p>Clears this Sparse Virtual File.</p>
<p>This removes all data and resets the internal counters.</p>
<dl class="section note"><dt>Note</dt><dd>m_coalesce, m_file_mod_time are maintained.</dd>
<dd>
m_time_write, m_time_read are maintained. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00849">849</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a5f7d0ea05d7a27e94ffbb3a74cb8d150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7d0ea05d7a27e94ffbb3a74cb8d150">&#9670;&nbsp;</a></span>config()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_s_v_f_s.html#a1eab55d2643d9e51c4f4595b78afe9af">tSparseVirtualFileConfig</a>&amp; SVFS::SparseVirtualFile::config </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The configuration. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00373">373</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="aa2e68937e422d8935e08fa8498e2d449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e68937e422d8935e08fa8498e2d449">&#9670;&nbsp;</a></span>count_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::count_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count of <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad92b513994c68322312358db4197ac94" title="Read data and write to the buffer provided by the caller. This is non-const as it updates the non-con...">read()</a></code> operations. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00379">379</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="ad2678dc53b5e2ab15f3a82a4a699622a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2678dc53b5e2ab15f3a82a4a699622a">&#9670;&nbsp;</a></span>count_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::count_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count of <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5ae9a0a31892a3b41581ab888dd1323c" title="Write the data a the given file position.">write()</a></code> operations. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00376">376</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a92ffb36bd3061ea6e08fe2bbb72b5e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ffb36bd3061ea6e08fe2bbb72b5e32">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td>
          <td class="paramname"><em>fpos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a particular block. </p>
<p>Remove the block at the given file position which must be the start of the block. This will raise an ExceptionSparseVirtualFile if the file position is not the start of the block. Returns the length of the block erased.</p>
<p>This will raise an ExceptionSparseVirtualFileErase if the file position is not exactly at the start of a block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpos</td><td>File position of the start of the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the block that was removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00905">905</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a4466ba8fbac9b8112aa525efe913cb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4466ba8fbac9b8112aa525efe913cb2d">&#9670;&nbsp;</a></span>file_mod_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SVFS::SparseVirtualFile::file_mod_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The file modification time as a double representing UNIX seconds. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00370">370</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="ab3f5a5eedbf7de4923df56c4059882ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f5a5eedbf7de4923df56c4059882ba">&#9670;&nbsp;</a></span>file_mod_time_matches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVFS::SparseVirtualFile::file_mod_time_matches </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>file_mod_time</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the clients file modification time has changed. Caller has to decide what to do... </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00361">361</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="aa88502c3064a53388db887e176c9ba07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88502c3064a53388db887e176c9ba07">&#9670;&nbsp;</a></span>has()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVFS::SparseVirtualFile::has </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td>
          <td class="paramname"><em>fpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do I have the data at the given file position and length? </p>
<p>Returns <code>true</code> if this SVF already contains this data.</p>
<p>If <code>false</code> then <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ade33f55fdcee892fbc10a44aa219b6c5" title="Create a new fragmentation list of seek/read instructions.">need()</a></code> can say what exactly is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpos</td><td>File position. </td></tr>
    <tr><td class="paramname">len</td><td>Read length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this SVF already contains this data, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00056">56</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a47dba399c3b8d0b5c56c2053455132d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47dba399c3b8d0b5c56c2053455132d7">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SVFS::SparseVirtualFile::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The ID of the file. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00367">367</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="ac3bdd9522da5fb32237738fb3217ac7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bdd9522da5fb32237738fb3217ac7c">&#9670;&nbsp;</a></span>integrity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a0b3e9296b2987975edf1b2e8f60a15c6">SparseVirtualFile::ERROR_CONDITION</a> SVFS::SparseVirtualFile::integrity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal integrity check. </p>
<p>This checks for these error conditions:</p>
<ul>
<li>Empty block.</li>
<li>Duplicate block.</li>
<li>Adjacent blocks.</li>
<li>Overlapping blocks.</li>
<li>Byte count missmatch.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>An error condition or <code>ERROR_NONE</code> if the integrity is correct. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00927">927</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="ad87964eeb0075d83fb9e97bdf5e511df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87964eeb0075d83fb9e97bdf5e511df">&#9670;&nbsp;</a></span>last_file_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a> SVFS::SparseVirtualFile::last_file_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The position of the last byte. </p>
<p>Returns the largest possible file position known so far.</p>
<p>Of course this is not the EOF position as we may not have been offered that yet.</p>
<dl class="section return"><dt>Returns</dt><dd>The last known file position. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00972">972</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a2b2f1d0350fd4f69387c6363fb83b311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2f1d0350fd4f69387c6363fb83b311">&#9670;&nbsp;</a></span>lru_punt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::lru_punt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cache_size_upper_bound</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements a simple punting strategy based a Last Recently Used blocks. This brings the cache size to &lt; cache_size_upper_bound but leaving at least one block in place.</p>
<p>This will block in a multi-threaded environment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache_size_upper_bound</td><td>The upper bound of the final cache size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l01021">1021</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="ade33f55fdcee892fbc10a44aa219b6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade33f55fdcee892fbc10a44aa219b6c5">&#9670;&nbsp;</a></span>need()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a> SVFS::SparseVirtualFile::need </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td>
          <td class="paramname"><em>fpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>greedy_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new fragmentation list of seek/read instructions. </p>
<p>Given a file position and a length what data do I need that I don't yet have?</p>
<p>This takes an optional argument <code>greedy_length</code> that can be useful when dealing with remote files on high latency networks. The <code>greedy_length</code> will determine the minimum read length and this may well change a series of small reads into a shorter series of larger reads. This might well improve the read performance at the expense of cacheing extra unused data.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a1a687c5d6ccbc55dcee600eaf5e6e9b7" title="Given many [(file position, lengths), ...] what data do I need that I don&#39;t yet have?">need_many()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>greedy_length</code> might create read values that already exist in the SVF. If <code>SFVS::tSparseVirtualFileConfig</code> <code>compare_for_diff</code> is true then this will trigger a data comparison.</dd>
<dd>
If a <code>greedy_length</code> is given this will be the <em>minimum</em> size of the length of the required block. If the length of the required block is so large (because of existing blocks likely to be coalesced) then the user might want to split the length, for example, into multiple (smaller) GET requests which will then be coalesced on <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5ae9a0a31892a3b41581ab888dd1323c" title="Write the data a the given file position.">write()</a></code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The SVF has no knowledge of the the actual file size so when using a greedy length the need list might include positions beyond EOF. For example a file 1024 bytes long and a greedy length of 256 then <code>need(1000, 24, 256)</code> will create a need list of [(1000, 256),]. This should generate a <code>write(1000, 24)</code> not a <code>write(1000, 256)</code>. It is up to the caller to handle this, however, <code>reads()</code> in C/C++/Python will ignore read lengths past EOF so the caller does not have to do anything.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpos</td><td>File position at the start of the attempted read. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the attempted read. </td></tr>
    <tr><td class="paramname">greedy_length</td><td>If greater than zero this makes greedy, fewer but larger, reads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs (file_position, length) that this SVF needs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00582">582</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a1a687c5d6ccbc55dcee600eaf5e6e9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a687c5d6ccbc55dcee600eaf5e6e9b7">&#9670;&nbsp;</a></span>need_many()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a> SVFS::SparseVirtualFile::need_many </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#a5674f69324a17c418f065ce57c90538e">t_seek_reads</a> &amp;&#160;</td>
          <td class="paramname"><em>seek_reads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>greedy_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given many [(file position, lengths), ...] what data do I need that I don't yet have? </p>
<p>Create a new fragmentation list of seek/read instructions from a list of seek read instructions. Non-const argument as it will be sorted in-place.</p>
<p>This takes an optional argument <code>greedy_length</code> that can be useful when dealing with remote files on high latency networks. The <code>greedy_length</code> will determine the minimum read length and this may well change a series of small reads into a shorter series of larger reads. This might well improve the read performance at the expense of cacheing extra unused data.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ade33f55fdcee892fbc10a44aa219b6c5" title="Create a new fragmentation list of seek/read instructions.">need()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>greedy_length</code> might create read values that already exist in the SVF. If <code>SFVS::tSparseVirtualFileConfig</code> <code>compare_for_diff</code> is true then this will trigger a data comparison.</dd>
<dd>
If a <code>greedy_length</code> is given this will be the <em>minimum</em> size of the length of the required block. If the length of the required block is so large (because of existing blocks likely to be coalesced) then the user might want to split the length, for example, into multiple (smaller) GET requests which will then be coalesced on <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5ae9a0a31892a3b41581ab888dd1323c" title="Write the data a the given file position.">write()</a></code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The SVF has no knowledge of the the actual file size so when using a greedy length the need list might include positions beyond EOF. For example a file 1024 bytes long and a greedy length of 256 then <code>need(1000, 24, 256)</code> will create a need list of [(1000, 256),]. This should generate a <code>write(1000, 24)</code> not a <code>write(1000, 256)</code>. It is up to the caller to handle this, however, <code>reads()</code> in C/C++/Python will ignore read lengths past EOF so the caller does not have to do anything.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seek_reads</td><td>The vector of (file_position, length) objects. This will be sorted primarily by file position. </td></tr>
    <tr><td class="paramname">greedy_length</td><td>If greater than zero this makes greedy, fewer but larger, reads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs (file_position, length) that this SVF needs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00708">708</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a4031e0bf4b691bc702086bf2403a0777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4031e0bf4b691bc702086bf2403a0777">&#9670;&nbsp;</a></span>num_blocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::num_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of blocks used. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00354">354</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a480da981319d2a3a7d2ad46ce6055380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480da981319d2a3a7d2ad46ce6055380">&#9670;&nbsp;</a></span>num_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::num_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives exact number of data bytes held. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00351">351</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a7b3010a7cbd7f78ee8fd49f4fe0fc471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3010a7cbd7f78ee8fd49f4fe0fc471">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html">SparseVirtualFile</a> SVFS::SparseVirtualFile::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html">SparseVirtualFile</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminate copying. </p>

</div>
</div>
<a id="a08f8d6206706a1acf3a83466f7482fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f8d6206706a1acf3a83466f7482fef">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html">SparseVirtualFile</a>&amp; SVFS::SparseVirtualFile::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html">SparseVirtualFile</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad92b513994c68322312358db4197ac94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92b513994c68322312358db4197ac94">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVFS::SparseVirtualFile::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td>
          <td class="paramname"><em>fpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data and write to the buffer provided by the caller. This is non-const as it updates the non-const members such as <code>m_block_touch</code> etc. </p>
<p>Read data and write to the buffer provided by the caller. Not const as we update m_bytes_read, m_count_read, m_time_read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpos</td><td>File position to start the read. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the read. </td></tr>
    <tr><td class="paramname">p</td><td>Buffer to copy the data into. It is up to the caller to make sure that p can contain len chars. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00504">504</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a24e95ff6a7f05cdcb7d534bb4eabcb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e95ff6a7f05cdcb7d534bb4eabcb1a">&#9670;&nbsp;</a></span>size_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::size_of </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a24e95ff6a7f05cdcb7d534bb4eabcb1a" title="size_of() gives best guess of total memory usage.">size_of()</a> gives best guess of total memory usage. </p>
<p>Returns the total memory usage of this SVF.</p>
<dl class="section return"><dt>Returns</dt><dd>Memory used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00823">823</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<a id="a91bf020a4ff40d4d232bf8ff695c84a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bf020a4ff40d4d232bf8ff695c84a7">&#9670;&nbsp;</a></span>time_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::time_point&lt;std::chrono::system_clock&gt; SVFS::SparseVirtualFile::time_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Time of the last <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#ad92b513994c68322312358db4197ac94" title="Read data and write to the buffer provided by the caller. This is non-const as it updates the non-con...">read()</a></code> operation. If no reads have been made this returns <code>std::chrono::time_point&lt;std::chrono::system_clock&gt;::min()</code> This can be cast to <code>std::chrono::time_point&lt;double&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00406">406</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a4dad8e7b97912c6c5b54a5230fc306ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dad8e7b97912c6c5b54a5230fc306ac">&#9670;&nbsp;</a></span>time_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::time_point&lt;std::chrono::system_clock&gt; SVFS::SparseVirtualFile::time_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Time of the last <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#a5ae9a0a31892a3b41581ab888dd1323c" title="Write the data a the given file position.">write()</a></code> operation. If no writes have been made this returns <code>std::chrono::time_point&lt;std::chrono::system_clock&gt;::min()</code> This can be cast to <code>std::chrono::time_point&lt;double&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00399">399</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a5ae9a0a31892a3b41581ab888dd1323c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae9a0a31892a3b41581ab888dd1323c">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVFS::SparseVirtualFile::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f_s.html#ac5f0e5533875bd97b8497f6cfbbb0c31">t_fpos</a>&#160;</td>
          <td class="paramname"><em>fpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the data a the given file position. </p>
<p>This will either:</p>
<ul>
<li>Write a brand new block independent of all the others.</li>
<li>Write a new block and coalesce other blocks onto its end.</li>
<li>Coalesce the new block onto an existing block and possibly others.</li>
</ul>
<p>Comments are structures like this where:</p>
<ul>
<li><code>====</code> are existing blocks.</li>
<li><code>++++</code> is the new block. File position is the beginning of the <code>++++</code> block.</li>
<li><code>^====</code> shows where the iterator is pointing to.</li>
</ul>
<p>Notation:</p>
<ol type="1">
<li>Means original blocks.</li>
<li>Is new data to be added</li>
<li>Is the result.</li>
</ol>
<p>And the characters mean:</p>
<ul>
<li><code>=</code> Means original data.</li>
<li><code>+</code> Means new data.</li>
<li><code>c</code> Means data checked equal (if required).</li>
<li><code>A</code> Means new data appended or added.</li>
</ul>
<div class="fragment"><div class="line">1:       ^===========|    |=====|</div>
<div class="line">2: |+++++++++++++++++++++++++++++++++|</div>
<div class="line">3: |AAAAAAcccccccccccAAAAAAcccccAAAAA|</div>
</div><!-- fragment --><p>This also updates the write count, the number of bytes written and the last write time.</p>
<p>If <code>SVF_THREAD_SAFE</code> is defined then this will acquire a lock on this <code><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html" title="Implementation of a Sparse Virtual File.">SparseVirtualFile</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpos</td><td>The file position to write to. </td></tr>
    <tr><td class="paramname">data</td><td>The data, assumed to be of the given length. </td></tr>
    <tr><td class="paramname">len</td><td>The length to the data to write. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="svf_8cpp_source.html#l00453">453</a> of file <a class="el" href="svf_8cpp_source.html">svf.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af53a552eb5407bd0bdd840e993d10c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53a552eb5407bd0bdd840e993d10c2d">&#9670;&nbsp;</a></span>m_block_touch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_v_f_s.html#ae056c270d122162bdbdc2bce297e693c">t_block_touch</a> SVFS::SparseVirtualFile::m_block_touch</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A monotonically increasing integer that indicates the age of a block, smaller is older. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00471">471</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a50c71f2fd2d1aba0de7f4a38d10ae044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c71f2fd2d1aba0de7f4a38d10ae044">&#9670;&nbsp;</a></span>m_blocks_erased</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::m_blocks_erased</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total count of blocks that have been erased either directly or by punting. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00477">477</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a29a124b18adfd859010434f7966780d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a124b18adfd859010434f7966780d9">&#9670;&nbsp;</a></span>m_blocks_punted</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::m_blocks_punted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The count of blocks that have been erased by punting. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00481">481</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a49040796a4b59d7d2ac4285ec71ae3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49040796a4b59d7d2ac4285ec71ae3de">&#9670;&nbsp;</a></span>m_bytes_erased</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::m_bytes_erased</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total count of bytes that have been erased either directly or by punting. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00479">479</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a1b4a550ca8131b0f1b7a814ae6d367d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4a550ca8131b0f1b7a814ae6d367d0">&#9670;&nbsp;</a></span>m_bytes_punted</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::m_bytes_punted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The count of bytes that have been erased by punting. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00483">483</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a2736ef8a5cd7fb7d3a7e38015e3d7104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2736ef8a5cd7fb7d3a7e38015e3d7104">&#9670;&nbsp;</a></span>m_bytes_read</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::m_bytes_read = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access statistics: total bytes read. </p><dl class="section note"><dt>Note</dt><dd>These include any duplicate reads. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00455">455</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a254a9afdc57eed4b0c44ecaac4fa34cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254a9afdc57eed4b0c44ecaac4fa34cc">&#9670;&nbsp;</a></span>m_bytes_total</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::m_bytes_total = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of bytes in this SVF. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00445">445</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a42406904001643468eb4db07771fbcf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42406904001643468eb4db07771fbcf1">&#9670;&nbsp;</a></span>m_bytes_write</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::m_bytes_write = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access statistics: total bytes written. </p><dl class="section note"><dt>Note</dt><dd>These include any duplicate writes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00452">452</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a356bad14f44aaca0b0e0a334295a3d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356bad14f44aaca0b0e0a334295a3d87">&#9670;&nbsp;</a></span>m_config</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_v_f_s.html#a1eab55d2643d9e51c4f4595b78afe9af">tSparseVirtualFileConfig</a> SVFS::SparseVirtualFile::m_config</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The SVF configuration. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00443">443</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="adda4430a1d0ba01d27c84d2ad5af2860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda4430a1d0ba01d27c84d2ad5af2860">&#9670;&nbsp;</a></span>m_count_read</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::m_count_read = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access statistics: count of read operations. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00449">449</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a5500469ea7728c0332e7d7592e90f6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5500469ea7728c0332e7d7592e90f6f9">&#9670;&nbsp;</a></span>m_count_write</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVFS::SparseVirtualFile::m_count_write = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access statistics: count of write operations. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00447">447</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="ade5930e519f16ef64d6023381c2b010b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5930e519f16ef64d6023381c2b010b">&#9670;&nbsp;</a></span>m_file_mod_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SVFS::SparseVirtualFile::m_file_mod_time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The original file modification date as UNIX time. This is used for consistency checking. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00441">441</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="ae77810bd9ca991f4b462bb5d671026f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77810bd9ca991f4b462bb5d671026f7">&#9670;&nbsp;</a></span>m_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVFS::SparseVirtualFile::m_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The SVF ID. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00439">439</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="ad4ca5dd3feac91a4b891ebc13fe8ba6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ca5dd3feac91a4b891ebc13fe8ba6e">&#9670;&nbsp;</a></span>m_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex SVFS::SparseVirtualFile::m_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread mutex. This adds about 5-10% execution time compared with a single threaded version. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00474">474</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="ad723c792fb2ff20bca02461f0c15d1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad723c792fb2ff20bca02461f0c15d1b7">&#9670;&nbsp;</a></span>m_svf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_v_f_s_1_1_sparse_virtual_file.html#afa892b09c0fc5ffcfebcadf44b7b1035">t_map</a> SVFS::SparseVirtualFile::m_svf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The actual SVF. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00469">469</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a599beee3f87fd17a02cbca30d4f11152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599beee3f87fd17a02cbca30d4f11152">&#9670;&nbsp;</a></span>m_time_read</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::time_point&lt;std::chrono::system_clock&gt; SVFS::SparseVirtualFile::m_time_read</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Last access real-time timestamp for a read. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00459">459</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<a id="a2487ccdb7ad98eac1ba31600d2c618d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2487ccdb7ad98eac1ba31600d2c618d4">&#9670;&nbsp;</a></span>m_time_write</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::time_point&lt;std::chrono::system_clock&gt; SVFS::SparseVirtualFile::m_time_write</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Last access real-time timestamp for a write. </p>

<p class="definition">Definition at line <a class="el" href="svf_8h_source.html#l00457">457</a> of file <a class="el" href="svf_8h_source.html">svf.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/paulross/CLionProjects/cppSVF/src/cpp/<a class="el" href="svf_8h_source.html">svf.h</a></li>
<li>/Users/paulross/CLionProjects/cppSVF/src/cpp/<a class="el" href="svf_8cpp_source.html">svf.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
